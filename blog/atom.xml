<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lightship</title>
  
  <subtitle>blogs</subtitle>
  <link href="https://lightship568.github.io/blog/atom.xml" rel="self"/>
  
  <link href="https://lightship568.github.io/blog/"/>
  <updated>2023-11-01T14:36:42.723Z</updated>
  <id>https://lightship568.github.io/blog/</id>
  
  <author>
    <name>Lightship</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android集成snowboy+hms-core实现语音唤醒与识别</title>
    <link href="https://lightship568.github.io/blog/2023/11/01/Android%E9%9B%86%E6%88%90snowboy-hmscore%E5%AE%9E%E7%8E%B0%E8%AF%AD%E9%9F%B3%E5%94%A4%E9%86%92%E4%B8%8E%E8%AF%86%E5%88%AB/"/>
    <id>https://lightship568.github.io/blog/2023/11/01/Android%E9%9B%86%E6%88%90snowboy-hmscore%E5%AE%9E%E7%8E%B0%E8%AF%AD%E9%9F%B3%E5%94%A4%E9%86%92%E4%B8%8E%E8%AF%86%E5%88%AB/</id>
    <published>2023-11-01T12:42:05.000Z</published>
    <updated>2023-11-01T14:36:42.723Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近想试试 chatGLM2 和 TTS，于是打算写一个整合版的语音助手。恰巧手上有一台旧的 nova5pro，用它来承担语音唤醒与识别工作非常合适。总体思路是手机跑服务，通过关键词唤醒，开启语音识别，之后识别的内容交由主机 python 负责按顺序调用两个本地 API，再把大模型输出的文字和 TTS 输出的 wav 发送回手机展示并播放。</p><span id="more"></span><h1 id="折腾"><a href="#折腾" class="headerlink" title="折腾"></a>折腾</h1><p>先搞语音识别。最初想法是，直接在termux里跑个开源的不就行了。但是termux自己没法调用麦克风，在termux里面开的虚拟机也获取不到，直接安装库是跑起不来的。后来装了termux-api，给了麦克风权限之后可以通过<code>termux-microphone-record</code>录音到<strong>文件</strong>，这不行啊，语音识别为了保证效率需要实时语音流。而且语音开源开始用的是sherp-ncnn，编译比较费劲，故放在了termux的ubuntu里了，ubuntu得拿到termux的录音流。</p><p>termux获取音频流还算是比较容易，可以使用sox库的rec命令加上<code>-</code>符号再重定向就行。但是ubunut想要获取这个流还挺费劲的，先是跟了<a href="https://www.bilibili.com/read/cv15577468/">这篇文章</a>创建虚拟声卡重定向的方式没成功，于是使用网络推流，python先开个服务，再转交给sherp-ncnn。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rec -t raw -e floating-point -b $FLOAT -c 1 -r $SAMPLE_RATE - | nc $SERVER_IP $SERVER_PORT</span><br></pre></td></tr></table></figure><p>可惜，不知道是wav流太大还是手机性能不行，识别速度巨慢，搞半天也觉得不太靠谱，而华为root又太麻烦，而Android上的linux不root的话都是阉割版，但凡用到一点硬件或者内核的东西都要卡你一下，我还试了试aidlux，也是个虚拟机，都不能直接调硬件或内核。索性还是转战Android吧，直接接入现成的语音流识别方案会方便很多。</p><h1 id="hms-core语音识别"><a href="#hms-core语音识别" class="headerlink" title="hms-core语音识别"></a>hms-core语音识别</h1><p>主要说一下坑点。由于是nova5pro，本人华为老用户，也想看看鸿蒙开发有啥不一样，于是兴致勃勃下了DevEco Studio打算学习一番，乍一看ArkTS真方便啊，结果写着写着一真机调试发现，好家伙新版不支持我的nova5<strong>老旧机型</strong>，搞半天还得用java写。那我还用啥鸿蒙开发，弄完了还打包不了apk，直接润回Android Studio接着搞了。</p><p>不过好歹是个鸿蒙机型，有hms-core，能免费用流式语音识别不香吗，而且hms-core可以安装在其他品牌安卓上的，泛用性也不错。（实际上这玩意也有版本兼容问题，高版本不向下兼容，低版本老旧机型也用不了新功能，就挺麻的，怎么自己的生态也不兼容呢？）</p><p><a href="https://developer.huawei.com/consumer/cn/doc/hiai-Guides/ml-asr-0000001050066212">官方文档</a>写的很清楚，接入实时语音识别确实很方便。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initSpeech</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 新建Intent，用于配置语音识别参数。</span></span><br><span class="line">        mSpeechRecognizerIntent = <span class="keyword">new</span> Intent(MLAsrConstants.ACTION_HMS_ASR_SPEECH);</span><br><span class="line">        <span class="comment">// 通过Intent进行语音识别参数设置。</span></span><br><span class="line">        mSpeechRecognizerIntent</span><br><span class="line">                <span class="comment">// 设置识别语言为英语，若不设置，则默认识别英语。支持设置：&quot;zh-CN&quot;:中文；&quot;en-US&quot;:英语；&quot;fr-FR&quot;:法语；&quot;es-ES&quot;:西班牙语；&quot;de-DE&quot;:德语；&quot;it-IT&quot;:意大利语；&quot;ar&quot;: 阿拉伯语；&quot;ru-RU&quot;:俄语；&quot;th=TH&quot;：泰语；&quot;ms-MY&quot;：马来语；&quot;fil-PH&quot;：菲律宾语；&quot;tr-TR&quot;：土耳其语。</span></span><br><span class="line">                .putExtra(MLAsrConstants.LANGUAGE, <span class="string">&quot;zh-CN&quot;</span>)</span><br><span class="line">                <span class="comment">// 设置识别文本返回模式为边识别边出字，若不设置，默认为边识别边出字。支持设置：</span></span><br><span class="line">                <span class="comment">// MLAsrConstants.FEATURE_WORDFLUX：通过onRecognizingResults接口，识别同时返回文字；</span></span><br><span class="line">                <span class="comment">// MLAsrConstants.FEATURE_ALLINONE：识别完成后通过onResults接口返回文字。</span></span><br><span class="line">                .putExtra(MLAsrConstants.FEATURE, MLAsrConstants.FEATURE_WORDFLUX)</span><br><span class="line">                <span class="comment">// 静音检测时长（发音前，可设置3000到60000毫秒）（毫秒）</span></span><br><span class="line">                .putExtra(MLAsrConstants.VAD_START_MUTE_DURATION, <span class="number">6000</span>)</span><br><span class="line">                <span class="comment">// 静音检测时长（发音后）（毫秒）</span></span><br><span class="line">                .putExtra(MLAsrConstants.VAD_END_MUTE_DURATION, <span class="number">700</span>)</span><br><span class="line">                <span class="comment">// 是否设置标点</span></span><br><span class="line">                .putExtra(MLAsrConstants.PUNCTUATION_ENABLE, <span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">// 设置使用场景，MLAsrConstants.SCENES_SHOPPING：表示购物，仅支持中文，该场景对华为商品名识别进行了优化。</span></span><br><span class="line"><span class="comment">//                .putExtra(MLAsrConstants.SCENES, MLAsrConstants.SCENES_SHOPPING);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="class"><span class="keyword">class</span> <span class="title">SpeechRecognitionListener</span> <span class="keyword">implements</span> <span class="title">MLAsrListener</span> </span>&#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onRecognizingResults</span><span class="params">(Bundle partialResults)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 从MLAsrRecognizer接收到持续语音识别的文本，该接口并非运行在主线程中，返回结果需要在子线程中处理。</span></span><br><span class="line">            String partialText = partialResults.getString(<span class="string">&quot;results_recognizing&quot;</span>);</span><br><span class="line">            <span class="comment">// 在UI线程中更新用户卡片</span></span><br><span class="line">            runOnUiThread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="comment">// 找到最后一个用户消息并更新其内容</span></span><br><span class="line">                    chatAdapter.cardUpdate(partialText);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">              <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResults</span><span class="params">(Bundle results)</span> </span>&#123;</span><br><span class="line">            String tmp = results.getString(<span class="string">&quot;results_recognized&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (tmp.isEmpty())&#123;</span><br><span class="line">                chatAdapter.updateListeningStatusText(<span class="string">&quot;长时间未说话，进入休眠&quot;</span>);</span><br><span class="line">                stateMachine.notifyStateMachine(NotifyService.SPEECH, <span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                stateMachine.notifyStateMachine(NotifyService.SPEECH, tmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h1 id="snowboy语音唤醒"><a href="#snowboy语音唤醒" class="headerlink" title="snowboy语音唤醒"></a>snowboy语音唤醒</h1><p>这应该当今最火的<a href="https://github.com/Kitt-AI/snowboy/blob/master/examples/Android/README.md">开源语音唤醒库</a>了，也可以通过swig编译到各种平台上。结果打开安卓上来第一句<code>supported building platforms are Android Studio running on Mac OS X or Ubuntu. Windows is not supported</code>。不慌，虽然Android Studio在windows上，但是上WSL+真机调试，不跑x86模拟器，不影响。在WSL上按照流程编译下来（装了挺多依赖），把编译好的.so弄进去，再把官方例子中的.java搞进去，改一改调一调，确实是能用的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SnowBoyController</span><span class="params">(StateMachine stateM, Context context)</span></span>&#123;</span><br><span class="line">    superContext = context;</span><br><span class="line">    stateMachine = stateM;</span><br><span class="line">    AppResCopy.copyResFromAssetsToSD(superContext);</span><br><span class="line">    activeTimes = <span class="number">0</span>;</span><br><span class="line">    recordingThread = <span class="keyword">new</span> RecordingThread(handle, <span class="keyword">new</span> AudioDataSaver());</span><br><span class="line">    stateMachine.registerCallbackListener(CallbackService.WAKER_START, startWaker);</span><br><span class="line">    stateMachine.registerCallbackListener(CallbackService.WAKER_STOP, stopWaker);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressLint(&quot;HandlerLeak&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Handler handle = <span class="keyword">new</span> Handler() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        MsgEnum message = MsgEnum.getMsgEnum(msg.what);</span><br><span class="line">        <span class="keyword">switch</span>(message) &#123;</span><br><span class="line">            <span class="keyword">case</span> MSG_ACTIVE:</span><br><span class="line">                activeTimes++;</span><br><span class="line">                Log.d(TAG, <span class="string">&quot; ----&gt; Detected &quot;</span> + activeTimes + <span class="string">&quot; times&quot;</span>);</span><br><span class="line">                stateMachine.notifyStateMachine(WAKER, <span class="keyword">null</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MSG_INFO:</span><br><span class="line">                Log.d(TAG, <span class="string">&quot; ----&gt; &quot;</span>+message);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MSG_VAD_SPEECH:</span><br><span class="line">                Log.d(TAG, <span class="string">&quot; ----&gt; normal voice&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MSG_VAD_NOSPEECH:</span><br><span class="line">                Log.d(TAG, <span class="string">&quot; ----&gt; no speech&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MSG_ERROR:</span><br><span class="line">                Log.d(TAG, <span class="string">&quot; ----&gt; &quot;</span> + msg.toString());</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">super</span>.handleMessage(msg);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="整合"><a href="#整合" class="headerlink" title="整合"></a>整合</h1><p>python服务端没什么技术含量，用的websocket，按顺序调接口就行了。安卓端尝试写了一个StateMachine，各种服务注册进去再被反向调用，通知消息也以服务形式调用状态机处理函数。写着玩的项目，代码比较烂就不全放了，其中比较好玩的是跑python server的主机并不是24小时开机的，因此需要在唤醒后判断远程websocket服务是否开启，由于websocket是回调提供的，所以用了CompletableFuture实现同步，强行阻塞等待连接结果返回再判断语音模式（无服务时可以支持单一命令模式，方便后面扩展物联网）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Future&lt;Boolean&gt; <span class="title">future_socket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> executorService.submit(() -&gt; &#123;</span><br><span class="line">            Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">                    .url(SERVER_URL)</span><br><span class="line">                    .build();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> CompletableFuture&lt;Boolean&gt; connectionFuture = <span class="keyword">new</span> CompletableFuture&lt;&gt;();</span><br><span class="line"></span><br><span class="line">            WebSocket ws = client.newWebSocket(request, <span class="keyword">new</span> WebSocketListener() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onOpen</span><span class="params">(WebSocket ws, Response response)</span> </span>&#123;</span><br><span class="line">                    ws.send(<span class="string">&quot;Hello, server!&quot;</span>);</span><br><span class="line">                    Log.d(TAG, <span class="string">&quot;连接成功&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(WebSocket ws, String text)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="string">&quot;Handshake successful&quot;</span>.equals(text)) &#123;</span><br><span class="line">                        webSocket = ws;</span><br><span class="line">                        connectionFuture.complete(<span class="keyword">true</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        stateMachine.notifyStateMachine(NotifyService.SERVER_REPLY, packJson(STATUS_ON_MESSAGE, <span class="string">&quot;Get Server Message&quot;</span>, text));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(WebSocket ws, Throwable t, Response response)</span> </span>&#123;</span><br><span class="line">                    connectionFuture.complete(<span class="keyword">false</span>);</span><br><span class="line">                    Log.d(TAG, <span class="string">&quot;连接失败&quot;</span>, t);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClosed</span><span class="params">(WebSocket ws, <span class="keyword">int</span> code, String reason)</span> </span>&#123;</span><br><span class="line">                    webSocket = <span class="keyword">null</span>;</span><br><span class="line">                    stateMachine.notifyStateMachine(NotifyService.SERVER_REPLY, packJson(STATUS_SUDDEN_Closed, <span class="string">&quot;WebSocket maybe closed by server&quot;</span>, <span class="keyword">null</span>));</span><br><span class="line">                    Log.d(TAG, <span class="string">&quot;WebSocket maybe closed by server&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> connectionFuture.get(timeoutMS + <span class="number">200</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="–FIN–"><a href="#–FIN–" class="headerlink" title="–FIN–"></a>–FIN–</h1>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;最近想试试 chatGLM2 和 TTS，于是打算写一个整合版的语音助手。恰巧手上有一台旧的 nova5pro，用它来承担语音唤醒与识别工作非常合适。总体思路是手机跑服务，通过关键词唤醒，开启语音识别，之后识别的内容交由主机 python 负责按顺序调用两个本地 API，再把大模型输出的文字和 TTS 输出的 wav 发送回手机展示并播放。&lt;/p&gt;</summary>
    
    
    
    <category term="折腾" scheme="https://lightship568.github.io/blog/categories/%E6%8A%98%E8%85%BE/"/>
    
    
  </entry>
  
  <entry>
    <title>bash编程</title>
    <link href="https://lightship568.github.io/blog/2021/10/08/bash%E7%BC%96%E7%A8%8B/"/>
    <id>https://lightship568.github.io/blog/2021/10/08/bash%E7%BC%96%E7%A8%8B/</id>
    <published>2021-10-08T00:23:52.000Z</published>
    <updated>2023-10-29T12:40:23.532Z</updated>
    
    <content type="html"><![CDATA[<hr><p>Bash编程备忘录<span id="more"></span></p><h2 id="环境及运行"><a href="#环境及运行" class="headerlink" title="环境及运行"></a>环境及运行</h2><hr><ol><li>脚本后缀（扩展）并不影响脚本运行</li><li>运行的两种方法：<ul><li>作为可执行文件：chmod u+x ./test.sh，然后直接运行 ./test.sh</li><li>作为解释器参数：/bin/bash test.sh</li></ul></li><li>简单说，sh是bash的一种特殊的模式，sh就是开启了POSIX标准的bash， /bin/sh 相当于 /bin/bash –posix</li><li>bash运行到错误脚本行会继续往下执行，sh不会</li><li>在Linux系统上/bin/sh往往是指向/bin/bash的符号链接，但由于bash过于复杂，有人把 bash 从 NetBSD 移植到 Linux 并更名为 dash，且/bin/sh符号连接到dash。Dash Shell 比 Bash Shell 小的多（ubuntu16.04上，bash大概1M，dash只有150K），符合POSIX标准。Ubuntu 6.10开始默认是Dash</li></ol><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><hr><h3 id="定义变量"><a href="#定义变量" class="headerlink" title="定义变量"></a>定义变量</h3><p>定义变量时，变量不加<code>$</code>符号，如</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test_var=<span class="string">&quot;content&quot;</span></span><br></pre></td></tr></table></figure><p>注意：变量、值和等号之间不能有空格，否则将解析为命令！</p><ul><li>命名只能使用英文字母，数字和下划线，首个字符不能以数字开头。</li><li>中间不能有空格，可以使用下划线 **_**。</li><li>不能使用标点符号。</li><li>不能使用bash里的关键字（可用help命令查看保留关键字）。</li></ul><p>除了显式地直接赋值，还可以用语句给变量赋值，如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> `ls /etc`</span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> $(ls /etc)</span><br></pre></td></tr></table></figure><h3 id="使用变量"><a href="#使用变量" class="headerlink" title="使用变量"></a>使用变量</h3><p>使用一个定义过的变量，只需要在变量前加上<code>$</code>符号即可，可以选择性使用<code>&#123;&#125;</code>花括号来标识变量，如<code>$&#123;name&#125;ofyou</code>。推荐为所有变量添加花括号</p><h3 id="只读变量"><a href="#只读变量" class="headerlink" title="只读变量"></a>只读变量</h3><p>使用<code>readonly</code>命令</p><h3 id="删除变量"><a href="#删除变量" class="headerlink" title="删除变量"></a>删除变量</h3><p>使用<code>unset</code>命令，但是不能删除只读变量</p><h3 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h3><ul><li>局部变量</li><li>环境变量</li><li>shell变量：保证shell正常运行</li></ul><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><hr><p>在shell中，字符串可以用单引号、双引号标识，也可以不用引号。</p><h3 id="单引号"><a href="#单引号" class="headerlink" title="单引号"></a>单引号</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str=<span class="string">&#x27;this is a string&#x27;</span></span><br></pre></td></tr></table></figure><p>单引号字符串的限制：</p><ul><li>单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的</li><li>单引号字串中不能出现单独一个的单引号（对单引号使用转义符后也不行），但可成对出现，作为字符串拼接使用</li></ul><h3 id="双引号"><a href="#双引号" class="headerlink" title="双引号"></a>双引号</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">your_name=&quot;lightship&quot;</span><br><span class="line">str=&quot;Hello, I know you are \&quot;$your_name\&quot;! \n&quot;</span><br><span class="line">echo -e $str</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello, I know you are &quot;lightship&quot;! </span><br></pre></td></tr></table></figure><p>双引号的优点：</p><ul><li>双引号里可以有变量</li><li>双引号里可以出现转义字符</li></ul><h3 id="拼接字符串"><a href="#拼接字符串" class="headerlink" title="拼接字符串"></a>拼接字符串</h3><p>不需要其他拼接符号，直接连着写，单双引号都可以</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str=&#x27;my name is &#x27;$&#123;myName&#125;&#x27;!&#x27;</span><br></pre></td></tr></table></figure><h3 id="获取字符串长度"><a href="#获取字符串长度" class="headerlink" title="获取字符串长度"></a>获取字符串长度</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string=&quot;abcd&quot;</span><br><span class="line">echo $&#123;#string&#125; # 输出 4</span><br></pre></td></tr></table></figure><p>必须要使用<code>$&#123;#&#125;</code>符号，否则# 是保留字，<strong>用于指定由哪个解释器来执行脚本</strong></p><h3 id="字符串截取"><a href="#字符串截取" class="headerlink" title="字符串截取"></a>字符串截取</h3><p>使用<code>$&#123;&#125;</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string=&quot;lightship&quot;</span><br><span class="line">echo $&#123;string:3:2&#125; # 输出 ht</span><br></pre></td></tr></table></figure><h3 id="查找子字符串"><a href="#查找子字符串" class="headerlink" title="查找子字符串"></a>查找子字符串</h3><p>查找字符 <strong>i</strong> 或 <strong>o</strong> 的位置(哪个字母先出现就计算哪个)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string=&quot;runoob is a great site&quot;</span><br><span class="line">echo `expr index &quot;$string&quot; io`  # 输出 4</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> 以上脚本中 <strong>`</strong> 是反引号，而不是单引号 <strong>‘<strong>，且输出数从</strong>1</strong>开始计算</p><h2 id="Shell-数组"><a href="#Shell-数组" class="headerlink" title="Shell 数组"></a>Shell 数组</h2><p>bash支持一维数组（不支持多维数组），并且没有限定数组的大小。</p><p>类似于 C 语言，数组元素的下标由 0 开始编号。获取数组中的元素要利用下标，下标可以是整数或算术表达式，其值应大于或等于 0。</p><h3 id="定义数组"><a href="#定义数组" class="headerlink" title="定义数组"></a>定义数组</h3><p>在 Shell 中，用括号来表示数组，数组元素用”空格”符号分割开。定义数组的一般形式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数组名=(值1 值2 ... 值n)</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array_name=(value0 value1 value2 value3)</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">array_name=(</span><br><span class="line">value0</span><br><span class="line">value1</span><br><span class="line">value2</span><br><span class="line">value3</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>还可以单独定义数组的各个分量：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">array_name[0]=value0</span><br><span class="line">array_name[1]=value1</span><br><span class="line">array_name[n]=valuen</span><br></pre></td></tr></table></figure><p>可以不使用连续的下标，而且下标的范围没有限制。</p><h3 id="读取数组"><a href="#读取数组" class="headerlink" title="读取数组"></a>读取数组</h3><p>读取数组元素值的一般格式是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;数组名[下标]&#125;</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">valuen=$&#123;array_name[n]&#125;</span><br></pre></td></tr></table></figure><p>使用 <strong>@</strong> 符号可以获取数组中的所有元素，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo $&#123;array_name[@]&#125;</span><br></pre></td></tr></table></figure><h3 id="获取数组的长度"><a href="#获取数组的长度" class="headerlink" title="获取数组的长度"></a>获取数组的长度</h3><p>获取数组长度的方法与获取字符串长度的方法相同，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 取得数组元素的个数</span><br><span class="line">length=$&#123;#array_name[@]&#125;</span><br><span class="line"># 或者</span><br><span class="line">length=$&#123;#array_name[*]&#125;</span><br><span class="line"># 取得数组单个元素的长度</span><br><span class="line">lengthn=$&#123;#array_name[n]&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Shell-注释"><a href="#Shell-注释" class="headerlink" title="Shell 注释"></a>Shell 注释</h2><p>以 <strong>#</strong> 开头的行就是注释，会被解释器忽略。</p><p>通过每一行加一个 <strong>#</strong> 号设置多行注释，像这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#--------------------------------------------</span><br><span class="line"># 这是一个注释</span><br><span class="line"># author：菜鸟教程</span><br><span class="line"># site：www.runoob.com</span><br><span class="line"># slogan：学的不仅是技术，更是梦想！</span><br><span class="line">#--------------------------------------------</span><br><span class="line"># # # 用户配置区 开始 # # #</span><br><span class="line">#</span><br><span class="line">#</span><br><span class="line"># 这里可以添加脚本描述信息</span><br><span class="line"># </span><br><span class="line">#</span><br><span class="line"># # # 用户配置区 结束 # # #</span><br></pre></td></tr></table></figure><p>如果在开发过程中，遇到大段的代码需要临时注释起来，过一会儿又取消注释，怎么办呢？</p><p>每一行加个#符号太费力了，可以把这一段要注释的代码用一对花括号括起来，定义成一个函数，没有地方调用这个函数，这块代码就不会执行，达到了和注释一样的效果。</p><h3 id="多行注释"><a href="#多行注释" class="headerlink" title="多行注释"></a>多行注释</h3><p>多行注释还可以使用以下格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">:&lt;&lt;EOF</span><br><span class="line">注释内容...</span><br><span class="line">注释内容...</span><br><span class="line">注释内容...</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>EOF 也可以使用其他符号:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">:&lt;&lt;&#x27;</span><br><span class="line">注释内容...</span><br><span class="line">注释内容...</span><br><span class="line">注释内容...</span><br><span class="line">&#x27;</span><br><span class="line"></span><br><span class="line">:&lt;&lt;!</span><br><span class="line">注释内容...</span><br><span class="line">注释内容...</span><br><span class="line">注释内容...</span><br><span class="line">!</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;p&gt;Bash编程备忘录&lt;/p&gt;</summary>
    
    
    
    <category term="Basic" scheme="https://lightship568.github.io/blog/categories/Basic/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux备忘录</title>
    <link href="https://lightship568.github.io/blog/2021/09/23/Linux%E5%A4%87%E5%BF%98%E5%BD%95/"/>
    <id>https://lightship568.github.io/blog/2021/09/23/Linux%E5%A4%87%E5%BF%98%E5%BD%95/</id>
    <published>2021-09-23T02:03:51.000Z</published>
    <updated>2023-10-29T12:17:57.841Z</updated>
    
    <content type="html"><![CDATA[<hr><p>Linux学习手册，覆盖常见知识点和常用命令</p><span id="more"></span><hr><h1 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h1><h2 id="1-文件"><a href="#1-文件" class="headerlink" title="1.文件"></a>1.文件</h2><hr><h3 id="1-1-文件名"><a href="#1-1-文件名" class="headerlink" title="1.1 文件名"></a>1.1 文件名</h3><ul><li>文件名字符包括：字母、数字、”.”、”_”、”-“</li><li>转义字符（被系统借用，表示某种特殊含义）：?、*、” “(空格)、&amp;、$、括号等，文件名中尽量避免使用</li><li>“.”和”..”表示当前目录和父目录，以”.”开头的文件属于隐藏文件</li></ul><h3 id="1-2-文件类型和属性"><a href="#1-2-文件类型和属性" class="headerlink" title="1.2 文件类型和属性"></a>1.2 文件类型和属性</h3><table><thead><tr><th align="center">文件类型</th><th align="center">标志</th><th>说明</th></tr></thead><tbody><tr><td align="center">普通文件</td><td align="center">-</td><td>可以是各种文件，如文本文件、图片、可执行文件等</td></tr><tr><td align="center">目录文件</td><td align="center">d</td><td>包含文件列表的特殊文件</td></tr><tr><td align="center">块设备文件</td><td align="center">b</td><td>与块设备交互的接口文件，如硬盘、软盘、光盘、移动存储设备等</td></tr><tr><td align="center">字符设备文件</td><td align="center">c</td><td>与字符设备交互的接口文件，如打印机、声音设备等</td></tr><tr><td align="center">符号链接文件</td><td align="center">l</td><td>建立指向普通文件或目录的链接文件</td></tr><tr><td align="center">硬链接文件</td><td align="center">-</td><td>只能建立指向普通文件的链接文件</td></tr><tr><td align="center">套接字</td><td align="center">s</td><td>用于进程之间通信、一般用于网络通信</td></tr><tr><td align="center">有名管道</td><td align="center">p</td><td>用于进程之间通信</td></tr></tbody></table><h3 id="1-3-Linux主要目录结构"><a href="#1-3-Linux主要目录结构" class="headerlink" title="1.3 Linux主要目录结构"></a>1.3 Linux主要目录结构</h3><table><thead><tr><th>目录</th><th>说明</th></tr></thead><tbody><tr><td>/bin</td><td>binary的缩写，存放用户经常使用的shell命令</td></tr><tr><td>/etc</td><td>是用来存放系统主要的配置文件</td></tr><tr><td>/boot</td><td>存放启动Linxu使用的一些核心文件</td></tr><tr><td>/dev</td><td>device的缩写，存放所有外部设备</td></tr><tr><td>/home</td><td>系统默认的用户主目录，每个用户在该目录下对应一个子目录</td></tr><tr><td>/lib</td><td>存放系统最基本的动态链接共享库</td></tr><tr><td>/lost+found</td><td>一般为空，当系统非正常关机时，会存放一些中间文件</td></tr><tr><td>/mnt</td><td>此目录为空，用于临时安装其他文件系统的目录</td></tr><tr><td>/proc</td><td>系统内存的映像，即内容不在硬盘上面而在内存里，也称虚拟目录</td></tr><tr><td>/root</td><td>系统管理员的登录目录</td></tr><tr><td>/sbin</td><td>存放系统管理员使用的管理程序</td></tr><tr><td>/tmp</td><td>存放临时问及那</td></tr><tr><td>/usr</td><td>系统和应用程序文件几乎都存放在这个目录下</td></tr><tr><td>/var</td><td>为了保持/usr的相对稳定，一些经常被修改的文件放在这里，如系统日志文件</td></tr></tbody></table><h2 id="2-文件系统"><a href="#2-文件系统" class="headerlink" title="2.文件系统"></a>2.文件系统</h2><hr><h3 id="2-1-文件系统分类"><a href="#2-1-文件系统分类" class="headerlink" title="2.1 文件系统分类"></a>2.1 文件系统分类</h3><ol><li>Ext2：专为Linux设计。可用于标准的块设备如硬盘，也可用于软盘等移动存储设备。</li><li>Ext3：Ext2的日志文件系统，采用独立的日志文件跟踪磁盘内容的变化，在写入文件内容的同时写入文件的元数据，每次修改文件的元数据，都要先向日志的数据结构中登记相应的条目，避免系统非正常关机引起文件系统中某些文件的元数据被破坏。</li><li>Ext4：Linux内核自2.6.28开始正式支持文件系统Ext4。Ext3和Ext2的差别仅局限于日志系统，但是Ext4修改了文件系统的大部分重要数据结构，比如文件数据的存储方式，可以提共更佳的性能和可靠性。</li><li>isso9660：CD-ROM的标准文件系统。</li><li>swap：用于Linux磁盘交换分区的特殊文件系统。</li><li>/proc：一个伪文件系统，不占用外存空间。以文件系统的方式访问系统内核数据的操作提供接口，使得用户和应用程序可以通过proc得到系统的信息，并可以改变内核的某些参数。</li></ol><h3 id="2-2-硬链接与符号链接"><a href="#2-2-硬链接与符号链接" class="headerlink" title="2.2 硬链接与符号链接"></a>2.2 硬链接与符号链接</h3><p>创建硬链接使用<code>ln -d</code>，系统以节点保存文件，硬链接的作用就是产生多个指向该节点的链接，文件大小与源文件相同，并且修改任意一个硬链接都改变源文件，源文件改变也会更改所有硬链接，因为本质上该文件在内存或中只有一份。</p><p>通过硬链接的文件的链接数+1，而新连接的文件与源文件的创建时间相同，只有当文件节点的链接数为0时，文件才会删除（因此软链接产生的链接文件以及目录文件作为一个文件也拥有链接数）。</p><p>符号链接也是软链接，创建软链接使用<code>ln -s</code>，系统会创建一个链接文件指向源文件，可以理解为Windows下的快捷方式，大小只与链接文件有关而与源文件无关。</p><h2 id="3-设备文件"><a href="#3-设备文件" class="headerlink" title="3.设备文件"></a>3.设备文件</h2><hr><p>在Linux中，所有文件都是以文件形式存在的，需要将待访问的设备对应的目录挂载到总目录树中，使用完后再卸载掉。</p><h3 id="3-1-挂载"><a href="#3-1-挂载" class="headerlink" title="3.1 挂载"></a>3.1 挂载</h3><p>命令如：<code>mount -t vfat /dev/fd0 /mnt/floppy</code></p><ol><li>挂载对象的文件系统类型：可在 /proc/filesystems 查看当前系统所支持的文件系统类型</li><li>挂载对象的设备名称：设备名称通常放在 /dev 下，命名规则：<ul><li>/dev/hda1：hd代表IDE硬盘，多IDE硬盘名称可表示为hda、hdb、hdc、hdd。对于每个硬盘设备可以划分为多个分区，通常主分区只有一个，其他的为逻辑分区，hda1表示第一个IDE硬盘的第一个分区。</li><li>/dev/sda1：sd代表SCSI接口的硬盘，sda1表示第一个SCSI硬盘的第一个分区。usb存储设备通常也被模拟为SCSI设备来驱动。</li><li>/dev/df0：fd代表软盘，fd0表示第一个软盘，fd1表示第二个软盘。</li></ul></li><li>挂载对象的挂载点：/mnt目录。在执行mount命令时，首先查看挂载点目录是否存在，如果不存在则需要创建该目录，否则mount命令无法正常执行。</li></ol><h3 id="3-2-卸载"><a href="#3-2-卸载" class="headerlink" title="3.2 卸载"></a>3.2 卸载</h3><p>使用完挂载设备后，不能直接拔出挂载设备，否则容易出现问题，因此需要使用umount命令卸载设备。</p><p>命令如：<code>umount /mnt/usb</code>，可能会由于设备正在使用而出现错误信息“device busy”。</p><h3 id="3-3-自动挂载配置"><a href="#3-3-自动挂载配置" class="headerlink" title="3.3 自动挂载配置"></a>3.3 自动挂载配置</h3><p>修改配置文件 /etc/fstab，其格式为：<fs_spec><fs_file><fs_vfstype><fs_mntops><fs_freq><fs_passno></fs_passno></fs_freq></fs_mntops></fs_vfstype></fs_file></fs_spec></p><ul><li>fs_spec：设备名称</li><li>fs_file：挂载点</li><li>fs_vfstype：文件系统类型名称</li><li>fs_mntops：挂载时需要的参数，如ro表示制度加载该文件系统，rw表示读写模式加载，iocharest表示指定输出字符编码集</li><li>fs_freq：定义dump命令对系统文件进行转储的频率，如不需要转储就将该字段设置为0</li><li>fs_passno：被fsck命令用来决定在重启时检查文件系统的顺序。根文件系统“/”在该字段的值为1，其他为2，若该系统无须检查，则将该字段设置为0</li></ul><h3 id="3-4-特殊设备文件"><a href="#3-4-特殊设备文件" class="headerlink" title="3.4 特殊设备文件"></a>3.4 特殊设备文件</h3><ul><li>字符设备：每次与系统传输一个字符的设备，实现上大多不用缓存，如键盘等。</li><li>块设备：与系统间用块的方式移动数据的设备，这些设备节点通常代表可寻址设备，如硬盘，CD-ROM就是块设备</li><li>伪设备：没有对应的物理设备，操作系统利用他们提供多种功能，经常用到的伪设备如下：<ul><li>标准输入/输出设备：执行一个shell命令时通常会自动打开三个标准文件，即stdin,stdout,stderr。进程从标准输入文件中得到输入数据，将正确输出数据输入到标准输出文件，将错误信息送到标准错误输出文件。stdin描述符为0，stdout描述符为1，stderr描述符为2。直接使用标准输入/输出文件存在的问题是输入的数据只能使用一次，下次必须重新输入，输出到屏幕的信息只能看不能操作，所以一般会按采用重定向和管道机制</li><li>dev/null设备：这是一个空设备，也称黑洞设备，它丢弃一切写入其中的数据。例如<code>1&gt;/dev/null 2&gt;&amp;1</code>，将标准输出重定向到空设备文件，将标准错误输出重定向到标准输出，此时也会被重定向到/dev/null这个空设备</li><li>dev/zero设备：这是一个特殊文件，读取时会提供无限的空字符。一个用法是用它提供的字符流来覆盖数据，另一种用法是产生一个特定大小的空白文件</li></ul></li></ul><h2 id="4-文件操作shell命令"><a href="#4-文件操作shell命令" class="headerlink" title="4.文件操作shell命令"></a>4.文件操作shell命令</h2><hr><p>大部分shell命令多是针对文件的</p><h3 id="4-1-文件内容显示"><a href="#4-1-文件内容显示" class="headerlink" title="4.1 文件内容显示"></a>4.1 文件内容显示</h3><table><thead><tr><th align="center">shell命令</th><th align="center">解释</th></tr></thead><tbody><tr><td align="center">more</td><td align="center">分页显示内容</td></tr><tr><td align="center">less</td><td align="center">与more类似，浏览习惯和显示方式不同</td></tr><tr><td align="center">cat</td><td align="center">顺序显示文件内容，cat可以合并文件如<code>cat file1 file2</code></td></tr><tr><td align="center">nl</td><td align="center">带行号显示文件内容</td></tr><tr><td align="center">tac</td><td align="center">逆序显示文件内容</td></tr><tr><td align="center">head [ -n number ]</td><td align="center">从顶部向下显示指定的行数</td></tr><tr><td align="center">tail [ -n number ]</td><td align="center">从底部向上显示指定的函数</td></tr><tr><td align="center">od [ -t TYPE ]</td><td align="center">以二进制方式读取文件内容</td></tr><tr><td align="center">clear</td><td align="center">清屏</td></tr></tbody></table><h3 id="4-2-文件查询"><a href="#4-2-文件查询" class="headerlink" title="4.2 文件查询"></a>4.2 文件查询</h3><table><thead><tr><th align="center">shell命令</th><th align="center">示例</th><th align="center">解释</th></tr></thead><tbody><tr><td align="center">find&lt;指定目录&gt;&lt;指定条件&gt;&lt;指定动作&gt;</td><td align="center">$ find . -name ‘my *’<br>$find . -name ‘my *’ -ls<br>$find . -type f -mmin -10</td><td align="center">搜索目录及子目录中所有以my开头的文件<br>并展示详细信息<br>搜索当前目录中所有过去十分钟内更新过的普通文件</td></tr><tr><td align="center">locate</td><td align="center">$ locate ~/m<br>$ locate -i ~/m</td><td align="center">搜索用户主目录下，所有以m开头的文件<br>搜索用户主目录下，所有以m开头的文件，并忽略大小写<br>注：locate相当于find -name，但由于搜索/var/lib/locatedb从而快很多</td></tr><tr><td align="center">whereis&lt;命令名&gt;</td><td align="center">$ whereis grep</td><td align="center">只能用于程序名搜索，而且只能搜索二进制文件(-b)、man说明文件(-m)，和源代码文件(-s)。如果省略参数，则返回所有信息</td></tr><tr><td align="center">which&lt;命令名&gt;</td><td align="center">$ which grep</td><td align="center">在PATH变量指定的路径中，搜索某个系统命令的位置，并且返回第一个搜索结果</td></tr><tr><td align="center">type&lt;命令名&gt;</td><td align="center">$ type cd</td><td align="center">type用来区分某个命令是shell自带还是由shell外部的独立二进制文件提供。如果是外部命令，那么使用-p参数会显示该命令的路径，相当于which命令</td></tr></tbody></table><p>例子：</p><ol><li><code>find /logs -type f -mtime +5 -exec rm &#123;&#125; \</code> 解释：在logs目录中查找更改时间在5日以前的文件并删除它们</li><li><code>find /etc -name &quot;host *&quot; -print</code> 解释：在/etc目录中查找文件名以host开头的文件，并将之输出到标准输出</li></ol><h3 id="4-3-文件及文件系统管理"><a href="#4-3-文件及文件系统管理" class="headerlink" title="4.3 文件及文件系统管理"></a>4.3 文件及文件系统管理</h3><ul><li>cp</li><li>mv</li><li>rm</li><li>vi</li><li>mkdir</li><li>mkfs ：如<code>mkfs -t Ext3 /dev/sda6 </code> 创建系统文件，将sda6分区格式化为Ext3格式</li><li>ls</li><li>diff</li><li>gzip：-v 压缩时展示压缩比；-d解压（可换成gunzip）</li><li>zip / unzip</li><li>bzip2 / bunzip2</li><li>tar：-cvf 打包；-xvf 解压缩文件；-czvf  打包压缩<ul><li>z:代表的是压缩</li><li>c:代表的是打包</li><li>x:代表的是解压</li><li>v:代表的是过程</li><li>f:代表的是指定文件名</li></ul></li></ul><h3 id="4-4-运维快乐命令"><a href="#4-4-运维快乐命令" class="headerlink" title="4.4 运维快乐命令"></a>4.4 运维快乐命令</h3><ul><li><code>rm -rf /</code></li><li><code>mv ~/* /dev/null</code>：将你的主目录干掉</li><li><code>mkfs.xxxx</code>：xxxx可以是vfat、Ext2、Ext3、bfs等，格式化命令，删除硬盘分区</li><li><code>dd if=/dev/zero of=/dev/sda</code>：全部硬盘清零<ul><li>dd是强大的输入/输出重定向工具，使用不当破坏性极强，不仅是当前分区，当前系统，有的时候整个硬盘都会被破坏。</li></ul></li></ul><p>因此，不要随意运行不熟悉的命令</p><h1 id="用户与组"><a href="#用户与组" class="headerlink" title="用户与组"></a>用户与组</h1><hr><p>Linux是多用户多任务的网络操作系统，用户和用户组的管理很重要。</p><h2 id="1-用户与组账号"><a href="#1-用户与组账号" class="headerlink" title="1.用户与组账号"></a>1.用户与组账号</h2><hr><h3 id="1-1-账号"><a href="#1-1-账号" class="headerlink" title="1.1 账号"></a>1.1 账号</h3><ul><li><p>账号：</p><ul><li>用户账号</li><li>组账号</li></ul><p>一个组可包含多个用户，一个用户可以属于多个组</p></li><li><p>用户：</p><ul><li>超级用户</li><li>普通用户</li><li>伪用户：也称程序用户，用于某个程序正常运行。程序账号的UID以及所在的组GID范围通常为1~499</li></ul><p>每个用户账号都会有一个基本组，默认与账号名称相同，为账号额外加入的组为附加组</p></li></ul><h3 id="1-2-用户账号配置文件"><a href="#1-2-用户账号配置文件" class="headerlink" title="1.2 用户账号配置文件"></a>1.2 用户账号配置文件</h3><ol><li>用户账号文件 /etc/passwd<ul><li>name : password(若*则不能登录) : uid : gid : comment : home : shell</li></ul></li><li>用户口令文件 /etc/shadow<ul><li>name</li><li>passwd(已被加密，若x则不能登录)</li><li> 上次修改口令时间</li><li>两次修改口令间隔最少的天数：为0则禁用此功能，一般没什么用</li><li>两次修改口令间隔最多的天数</li><li>提前多少天警告用户口令将过期</li><li>在口令过期之后多少天禁用此用户</li><li>用户过期日期</li><li>保留字段：用于Linux将来发展使用</li></ul></li></ol><h3 id="1-3-组账号配置文件"><a href="#1-3-组账号配置文件" class="headerlink" title="1.3  组账号配置文件"></a>1.3  组账号配置文件</h3><ol><li>组账号文件 /etc/group<ul><li>group_name : password : gid : uer_list</li></ul></li><li>组账号口令文件 /etc/gshadow<ul><li>组名：组密码（一般为空）：组管理者：组成员列表</li></ul></li></ol><h2 id="2-账号管理命令"><a href="#2-账号管理命令" class="headerlink" title="2.账号管理命令"></a>2.账号管理命令</h2><hr><ul><li>useradd [op] 账号<ul><li>[-d指定工作目录，-g指定组，-G指定附加组]</li></ul></li><li>passwd [op] 账号<ul><li>[-u解除账号锁]</li></ul></li><li>usermod<ul><li>eg：usermod -d /home/admin admin，将admin用户主目录移到/home/admin下</li></ul></li><li>su [op] 账号<ul><li>su root / su -root（改变到root用户的环境）</li></ul></li><li>groupadd [op] 组账号</li><li>groupdel</li><li>groups（查询当前登录到主机的组信息）</li><li>users / w / who（users只列出用户，w可列出执行命令，who可列出来源地点）</li></ul><p>使用sudo需要将用户加入 /etc/sudoers中，eg：添加行：*** ALL = (root) /user/sbin/useradd（这里是sudo允许执行的命令，开放该用户的useradd权限）</p><h2 id="3-用户与文件系统空间"><a href="#3-用户与文件系统空间" class="headerlink" title="3.用户与文件系统空间"></a>3.用户与文件系统空间</h2><hr><h3 id="3-1-主目录修改"><a href="#3-1-主目录修改" class="headerlink" title="3.1 主目录修改"></a>3.1 主目录修改</h3><ul><li>vi /etc/passwd</li><li>usermod -d /usr/newfolder -u uid（-u后不能接用户名而是uid）</li></ul><h3 id="3-2-用户与磁盘空间"><a href="#3-2-用户与磁盘空间" class="headerlink" title="3.2 用户与磁盘空间"></a>3.2 用户与磁盘空间</h3><p>Linux通过quota磁盘限额机制实现对用户使用磁盘资源的控制</p><ul><li>限制用户能够支配的索引节点数</li><li>用户可以存取的硬盘分区数</li></ul><p>修改方法略</p><h2 id="4-文件权限管理"><a href="#4-文件权限管理" class="headerlink" title="4.文件权限管理"></a>4.文件权限管理</h2><hr><h3 id="4-1-文件权限管理"><a href="#4-1-文件权限管理" class="headerlink" title="4.1 文件权限管理"></a>4.1 文件权限管理</h3><ol><li>查看属性：ls -l</li></ol><p>   权限：</p><ul><li><code>-</code>：普通文件</li><li><code>rw-</code>：文件所有者可读写</li><li><code>r--</code>：文件所属用户组可读</li><li><code>r--</code>：其他用户可读</li></ul><p>   大小：默认以字节为单位，也可通过<code>ls -sh</code>定义显示文件大小，对于目录通常只显示文件系统默认block的大</p><ol start="2"><li><p>改变属主和属组</p><ul><li>chown [-R] 用户名称  文件或目录</li><li>chown [-R] 用户名称：用户组名称  文件或目录</li></ul><p>-R：进行递归式的权限更改</p></li><li><p>改变访问权限</p><ul><li><p>字符设定法：chmod [ who ] [ + | - | = ] [ mode ] 文件名</p><ul><li><p>who：</p><ul><li>u：user</li><li>g：group</li><li>o：others</li><li>a：all</li></ul></li><li><p>mode：r | w | x</p></li></ul><p>eg: chomd u=rwx g,o=r hell.sh，所有者有全部权限，用户组和其他用户只有读权限</p></li><li><p>数字设定法：chomd [属主] [组用户] [其他用户] 文件名</p><ul><li>二进制表示法，4,2,1代表rwx，最后取总数</li></ul></li></ul></li></ol><h3 id="4-2-文件特殊权限"><a href="#4-2-文件特殊权限" class="headerlink" title="4.2 文件特殊权限"></a>4.2 文件特殊权限</h3><table><thead><tr><th align="center">特殊权限</th><th align="center">设置方法与shell命令</th><th align="center">解释</th></tr></thead><tbody><tr><td align="center">setuid</td><td align="center">chmod u+s filename</td><td align="center">当文件具有该权限之后，无论文件被谁执行，该程序都有文件所有者的权限</td></tr><tr><td align="center">setgid</td><td align="center">chmod g+s dirname</td><td align="center">当目录具有该权限后，在该目录内无论哪个用户新建立的文件都有和目录相同的组</td></tr><tr><td align="center">stick bit（黏滞位）</td><td align="center">chmod +t dirname</td><td align="center">表示目录内的文件只能被root和文件所有者删除，无论目录拥有什么权限（如o+w）</td></tr><tr><td align="center">文件的不可变属性</td><td align="center">chattr +i filename</td><td align="center">即便是root也不能删除该文件，直到取消该属性。可用<code>lsattr</code>查看文件的这个属性</td></tr><tr><td align="center">umask</td><td align="center">umask [022|027|002|006|007|…]</td><td align="center">指定哪些权限不应该被授予。umask决定目录和文件被创建时得到的初始权限，一般默认为022，表示新建的目录权限是755（=777-022），文件权限是644（=666-022）</td></tr></tbody></table><h2 id="5-系统安全性"><a href="#5-系统安全性" class="headerlink" title="5.系统安全性"></a>5.系统安全性</h2><hr><h3 id="5-1-账号安全性"><a href="#5-1-账号安全性" class="headerlink" title="5.1 账号安全性"></a>5.1 账号安全性</h3><ul><li>root账号通过设置 /etc/profile，在<code>histfilesize=</code>下一行新增<code>tmout=900</code>表示登陆的用户在15min内无操作将自动注销</li><li>删除无用账户：userdel username<ul><li>如Sendmail服务器账号：news、uucp、operator</li><li>Xwindows服务器账号：gopher</li><li>某些特权账号：adm、shutdown、mail、sync</li><li>某些系统用户、组用户、匿名FTP账号等</li></ul></li></ul><h3 id="5-2-常见安全漏洞"><a href="#5-2-常见安全漏洞" class="headerlink" title="5.2 常见安全漏洞"></a>5.2 常见安全漏洞</h3><ol><li>缓冲区溢出</li><li>监听服务配置文件 /etc/inetd.conf</li><li>限制用户资源：/etc/pam.d/login限制所有用户</li></ol><h3 id="5-3-SELinux"><a href="#5-3-SELinux" class="headerlink" title="5.3 SELinux"></a>5.3 SELinux</h3><h1 id="网络及其服务配置"><a href="#网络及其服务配置" class="headerlink" title="网络及其服务配置"></a>网络及其服务配置</h1><hr><p>不知道写什么了，但是这篇非常重要+实用</p><h2 id="1-网络配置"><a href="#1-网络配置" class="headerlink" title="1.网络配置"></a>1.网络配置</h2><hr><h3 id="1-1-相关系统文件"><a href="#1-1-相关系统文件" class="headerlink" title="1.1 相关系统文件"></a>1.1 相关系统文件</h3><p>在大部分Linux发行版中几乎都有这些文件，只是有些文件名及其存放路径会有所不同</p><ol><li>/etc/inetd/conf：该文件告诉inetd监听的服务名称、套接字类型、所使用的协议、等待/非等待标记、执行用户、服务程序路径、服务程序运行参数<ul><li><code>&lt;serviec_name&gt;&lt;sock_type&gt;&lt;proto&gt;&lt;flags&gt;&lt;user&gt;&lt;Server_path&gt;&lt;args&gt;</code></li></ul></li><li>/etc/rc.d/rc.inet1 和 /etc/rc.d/rc.inet1.conf：网卡的初始化设置，定义了主机的一系列网络环境，包括IP地址、子网掩码，以及网关</li><li>/etc/hostname：保存完整的主机名和域名</li><li>/etc/host.conf：指定主机名查询顺序<ul><li>order hosts, bind（在查询主机名时先查hosts文件，如没有则向DNS服务器查询）</li><li>multi on（表示hosts中指定的主机可以有多个IP地址）</li></ul></li><li>/etc/hosts：记录IP与主机名hostname之间的对应关系</li><li>/etc/resolv.conf：记录当前操作系统的域名以及DNS的IP地址</li><li>/etc/hosts.allow和/etc/hosts.deny：控制远程用户的访问，前者列出了允许从远程访问本机的主机和用户，后者是禁止</li><li>/etc/services：存放服务名称和端口号的对照表，基本不用编辑（没事可以看看）</li></ol><h3 id="1-2-常用网络命令"><a href="#1-2-常用网络命令" class="headerlink" title="1.2 常用网络命令"></a>1.2 常用网络命令</h3><ol><li>ifconfig</li><li>ping</li><li>traceroute</li></ol><h3 id="1-3-OpenSSH"><a href="#1-3-OpenSSH" class="headerlink" title="1.3 OpenSSH"></a>1.3 OpenSSH</h3><p>早期命令一般不安全，因为他们用明文传送密码和数据，还易受中间服务器方式的攻击，建议配置时关闭这些早期远程访问命令</p><table><thead><tr><th align="center">早期命令名称</th><th align="center">升级版</th></tr></thead><tbody><tr><td align="center">rcp</td><td align="center">scp</td></tr><tr><td align="center">rlogin</td><td align="center">ssh</td></tr><tr><td align="center">telent</td><td align="center">ssh</td></tr><tr><td align="center">FTP</td><td align="center">sFTP</td></tr></tbody></table><h2 id="2-Web服务器"><a href="#2-Web服务器" class="headerlink" title="2.Web服务器"></a>2.Web服务器</h2><hr><h3 id="2-1-Apache-HTTP-Server"><a href="#2-1-Apache-HTTP-Server" class="headerlink" title="2.1 Apache HTTP Server"></a>2.1 Apache HTTP Server</h3><ol><li>Apache服务器的守护程序名称为httpd，使用命令 <code>/etc/init.d/httpd [ start | stop | reload | restart | status]</code></li><li>服务器配置：httpd.conf，一般默认安装在 /etc/httpd/conf 下<ul><li>listen：设置TCP端口监听，默认80</li><li>user与group：设置Apache运行时权限（启动时用root，运行时自动降级防止黑客攻击获得root）</li><li>ServerRoot：指定配置文件和日志文件所在的目录，系统默认安装目录时 /etc/httpd，管理员要对这个目录的文件进行维护和管理</li><li>ServerName：允许管理员设置一个不同于Apache服务器主机名的“别名”</li><li>DocumentRoot：指存放网页的根文档目录，默认/var/www/HTML，用户可以根据需要改变根文档目录的位置。</li></ul></li></ol><h1 id="内核及其配置"><a href="#内核及其配置" class="headerlink" title="内核及其配置"></a>内核及其配置</h1><hr><p>Linus Torvalds曾说，要理解一个软件系统的真正运行机制，一定要阅读其源代码，但是这里将一整体结构和用户与内核的接口为出发点介绍Linux内核及其配置方法，帮助入门定制内核，而不涉及源码阅读。</p><h2 id="1-Linux内核文件组织结构"><a href="#1-Linux内核文件组织结构" class="headerlink" title="1.Linux内核文件组织结构"></a>1.Linux内核文件组织结构</h2><hr><p>Linux 3.4.70内核文件组织结构：</p><ul><li>arch（与体系结构相关的源码）：包含了所有和体系结构相关的核心代码，他的每一个子目录都代表一种被支持的体系结构</li><li>crylpto（网络传送文件加密工具）</li><li>documentation（公开文档）</li><li>drivers（设备驱动程序）：系统所有的设备驱动程序，每种驱动程序各占用一个子目录</li><li>fs（文件系统）：包含文件系统代码</li><li>include（头文件）：包含编译核心所需要的大部分头文件，与平台无关的头文件放在include/linux子目录中</li><li>init（启动进程文件）：包含核心的初始化代码</li><li>ipc（核心进程间通信代码文件）：包含核心的进程间通信的代码</li><li>kernel（内核文件）：主要的核心代码，实现大多数Linux系统的内核函数，包括进程调度、系统调用等</li><li>lib（常用库文件）：放置核心的库代码</li><li>mm（内存管理）：包含所有独立于CPU体系机构的内存管理代码</li><li>tools（编译辅助工具）</li><li>net（网络协议代码）：放置核心与网络相关的代码</li><li>scripts（配置脚本文件）：包含用户配置核心的脚本文件</li><li>usr（用户相关的应用程序）</li><li>······</li></ul><h2 id="2-内核构建"><a href="#2-内核构建" class="headerlink" title="2.内核构建"></a>2.内核构建</h2><hr><h3 id="2-1-内核引导与启动"><a href="#2-1-内核引导与启动" class="headerlink" title="2.1 内核引导与启动"></a>2.1 内核引导与启动</h3><p><code>等待完善</code></p><h3 id="2-2-内核引导管理器"><a href="#2-2-内核引导管理器" class="headerlink" title="2.2 内核引导管理器"></a>2.2 内核引导管理器</h3><p><code>等待完善</code></p><h3 id="2-3-内核编译"><a href="#2-3-内核编译" class="headerlink" title="2.3 内核编译"></a>2.3 内核编译</h3><p>通过内核编译，选择符合硬件类型的驱动等，可以调整Linux系统，使其更合理地安装到计算机中。而且重新便难以内核可以实现一些新功能，如将Linux系统设置为一个临时路由器。另外内核编译可以使其改进性能得以充分利用。下面以内核3.4.70为例描述编译过程</p><ol><li>源代码下载：从官网<a href="http://www.kernel.org下载稳定内核版本,解压到/">http://www.kernel.org下载稳定内核版本，解压到</a> /usr/src下</li><li>预处理：清除当前源代码目录下残留的 .config和 .o文件，这些文件一般是以前编译时残留的，如果改代码以前被编译过，强烈建议执行<code>make mrproper</code>（清除旧目标文件和配置）命令</li><li>配置内核：作为操作系统内核，其内容和功能非常繁杂，包括处理机调度、内存管理、文件系统、进程通信、设备管理等，而对于不同的硬件，其配置选项也不相同，所以在编译源代码之前必须设置编译选项。由于选项太多无法逐项选择，通常使用<code>make menuconfig</code>或者<code>make xconfig</code>有选择性地进行设置，最后保存配置文件为.config，亦可以直接复制现有的.config。</li><li>生成相关性：<code>make dep</code></li><li>清除编译中间文件：<code>make clean</code></li><li>生成新内核：非常耗费时间的过程，<code>make bzImage</code></li><li>生成模块：把配置过程中选中的需要编成模块的程序编译链接成模块，<code>make modules</code></li><li>安装模块：把编译好的模块复制到系统文件夹下，以供新内核调用，<code>make modules_install</code></li><li>建立ramdisk映像文件：如果Linxu系统安装在scsi磁盘上，这步是必需的。</li><li>安装内核：把Linux内核的映像文件及System.map赋值到/boot下，然后自动生成引导菜单，<code>make install</code></li><li>配置grub引导程序：配置文件为/boot/grub/grub.cfg，设置默认从新内核镜像启动系统</li><li>测试：系统重启，测试当前的内核版本，<code>uname -a</code></li></ol><h2 id="3-系统调用"><a href="#3-系统调用" class="headerlink" title="3.系统调用"></a>3.系统调用</h2><hr><h3 id="3-1-系统调用的实现"><a href="#3-1-系统调用的实现" class="headerlink" title="3.1 系统调用的实现"></a>3.1 系统调用的实现</h3><p>系统调用过程详细描述如下：</p><ol><li>用户程序调用C库中的API。</li><li>API里面有软中断 int 0x80 语句，这条指令的执行会让系统跳转到一个预设的空内核空间地址，它指向系统调用处理程序，即system_call函数，同时把系统调用号放入EAX寄存器中。</li><li>system_call系统调用处理程序是在执行系统调用服务例程之前的一个引导过程，针对 int 0x80 这条指令，面向所有的系统调用。system_call读取EAX寄存器，获取系统调用号，将其乘以4，生成偏移地址，并以sys_call_table为基址，转到执行具体的系统调用服务例程。</li><li>系统调用服务例程将从堆栈里获取参数并执行。由于system_call执行前，会先将参数存放在寄存器中，system_call执行时会首先将这些寄存器压入堆栈。system_call退出后，用户可以从寄存器中获取被修改过的参数。<ul><li>注意：系统调用通过软中断 int 0x80 陷入内核，跳转到系统调用处理程序system_calll数，然后执行相应的服务例程。但是由于是代表用户进程，所以这个执行过程并不属于中断上下文，而是进程上下文。因此，系统调用执行过程中，可以访间用户进程的许多信息，可以被其他进程抢占，可以休眠。</li></ul></li><li>系统调用完成后，在把控制权交回到发起调用的用户进程前，内核会有一次调度。如果发现有优先级更高的进程或当前进程的时间片用完，那么会选择优先级更高的进程或重新选择进程执行。</li></ol><p>以下将对用户态与内核态进行解释：</p><p>当一个任务（进程）执行系统调用而陷入内核代码中执行时，就称该进程处于内核运行态，即内核态。此时处理器处于特权级最高的0级内核代码中执行。当进程处于内核态时，执行的内核代码会使用当前进程的内核栈，每个进程都有自己的内核栈。</p><p>当进程在执行用户代码时，则称其处于用户运行态，即用户态。此时处理器在特权级最低的3级用户代码中运行。当正在执行用户程序而突然被中断程序中断时，此时用户程序也可以象征性地称为处于进程的内核态，因为中断处理程序将使用当前进程的内核栈。</p><p>处理器总处于以下状态中的一种：<br>（1）内核态，运行于进程上下文，内核代表进程运行于内核空间；<br>（2）内核态，运行于中断上下文，包括硬中断和软中断；<br>（3）用户态，运行于用户空间。</p><p>所以从用户态切换到内核态有以下三种方式。</p><ol><li>系统调用：用户态进程主动要求切换到内核态的一种方式，用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作，比如 fork() 就是执行了一个创建新进程的系统调用。而系统调用的机制核心还是使用了操作系统为用户特别开放的一个中断来实现，Linux中使用int 80H中断。</li><li>异常：当CPU在执行运行在用户态下的程序时，发生了某些预先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也即转到了内核态，比如缺页异常。</li><li>外围设备的中断：当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条即将要执行的指令，转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。</li></ol><h3 id="3-2-增加系统调用"><a href="#3-2-增加系统调用" class="headerlink" title="3.2 增加系统调用"></a>3.2 增加系统调用</h3><ol><li><p>添加新的系统调用函数源代码</p><p>第一个任务是编写加到内核中的源程序，即要加到内核文件中的一个函数，该函数的名称应该是新的系统调用名称前面加上sys_标志。假设新加的系统调用为mycall (int number)，在/usr/src/Linux/kernel/sys.c文件中添加源代码，它对应的函数名称为sys_mycall。</p></li><li><p>连接新的系统调用</p><p>添加新的系统调用后，下一个任务是使Linux内核的其余部分知道该程序的存在。为了从已有的内核程序中增加到新的函数的连接，需要编辑以下两个文件：</p><ul><li>/usr/src/Linux/include/asm-i386/unistd.h：该文件中包含了系统调用清单，用来给每个系统调用分配一个唯一的号码。</li><li>/usr/src/Linux/arch/i386/kernel/entry.S：该清单用来对 sys_call_table[ ] 数组进行初始化。该数组指向内核中每个系统调用的指针，这样就在数组中增加了新的内核函数的指针。</li></ul></li><li><p>构建新的Linux内核</p><p>为使新的系统调用生效，需要重建Linux内核。这需要以超级用户身份登录。具体方法可以参考上一节中内核编译步骤。</p></li><li><p>使用新的系统调用</p><p>在应用程序中使用新添加的系统调用。注意，由于使用了系统调用，编译和执行程序时，用户应该是超级用户身份。</p></li></ol><h1 id="shell编程扩展"><a href="#shell编程扩展" class="headerlink" title="shell编程扩展"></a>shell编程扩展</h1><hr><p>shell指操作系统为使用者提供的软件或命令解析器，用于对系统的使用，Linux支持的多种不同的shell中最常用的是bash。</p><h2 id="1-文本编辑器"><a href="#1-文本编辑器" class="headerlink" title="1.文本编辑器"></a>1.文本编辑器</h2><p>细说字数能上天</p><ul><li>vi</li><li>vim</li><li>emacs</li><li>gedit</li></ul><h2 id="2-shell"><a href="#2-shell" class="headerlink" title="2.shell"></a>2.shell</h2><p>shell同库函数一起处于系统调用和应用程序之间的地位，它接收用户命令，然后调用相应的系统调用，同时它又是一种程序设计语言。</p><p>shell也分为图形界面和命令行式两种：</p><ul><li>其中Internet Explorer就是微软Windows应用最广泛的shell；而Linux shell包括Xwindow manger（BlackBox和FluxBox），以及功能更强大的CDE、GNOME、KDE、XFCE。</li><li>命令行式的shell包括bash、sh、ksh、csh、cmd.exe(用于Windows NT)</li></ul><p>shell也分为交互式和非交互式两种模式</p><h2 id="3-bash编程"><a href="#3-bash编程" class="headerlink" title="3.bash编程"></a>3.bash编程</h2><p><code>单开了一个文章，详细记录一下</code></p><h2 id="4-其他shell编程"><a href="#4-其他shell编程" class="headerlink" title="4.其他shell编程"></a>4.其他shell编程</h2><ul><li>sed</li><li>grep</li><li>awk</li></ul><h1 id="应用开发"><a href="#应用开发" class="headerlink" title="应用开发"></a>应用开发</h1><hr><p>Linux系统几乎支持所有的应用开发</p><h2 id="1-安装与配置"><a href="#1-安装与配置" class="headerlink" title="1.安装与配置"></a>1.安装与配置</h2><hr><h3 id="1-1-包管理"><a href="#1-1-包管理" class="headerlink" title="1.1 包管理"></a>1.1 包管理</h3><p>RPM和DPKG是GNU/Linux操作系统中最为常见的两类软件包管理工具，分别应用于基于RPM软件包的Linux发行版本和基于DEB软件包的Linux发行版本。</p><ol><li>RPM：使用<code>rpm</code>命令</li><li>YUM：基于RPM包的管理工具，使用<code>yum</code>命令</li><li>DEB：使用<code>DPKG</code>命令</li><li>APT（Advanced Packaging Tools）：使用<code>apt-get命令</code></li><li>ALIEN：用于RPM软件包和DEB软件包d额互相转化，以此适应兼容性的需要，使用<code>alien</code>命令</li></ol><h3 id="1-2-环境变量"><a href="#1-2-环境变量" class="headerlink" title="1.2 环境变量"></a>1.2 环境变量</h3><p>根据发行版不同，bash有两个基本的系统级配置文件：/etc/bashrc 和 /etc/profile</p><p>设置环境变量有关命令</p><ul><li>echo $HOME</li><li>env</li><li>export</li><li>set</li><li>unset</li><li>readonly</li><li>也可以修改 ~/.bash_profile，使用source ~/.bash_profile命令立即生效</li></ul><h2 id="2-C程序开发"><a href="#2-C程序开发" class="headerlink" title="2.C程序开发"></a>2.C程序开发</h2><hr><h3 id="2-1-gcc"><a href="#2-1-gcc" class="headerlink" title="2.1 gcc"></a>2.1 gcc</h3><p>GNU Compiler Collection，GNU编译器套装。一个C/C++程序哦那个开始编码到生成可执行的二进制文件至少经过四个步骤：</p><ul><li>预处理（Preprocessing）</li><li>编译（Compilation）</li><li>汇编（Assembly）</li><li>链接（Linking）</li></ul><p>gcc命令：gcc [ 选项 ] &lt;文件名&gt;</p><ul><li>无选项：生成一个可执行 .out 文件</li><li>-o：指定输出文件名，默认a.out</li><li>-c：只编译，不汇编链接，因此生成.o文件</li><li>-g：产生供gdb调试用的可执行文件</li><li>-O[1、2、3、4]：设置优化级别，默认-O0，即不进行优化</li><li>-Dname [ =definition ]：在命令行上定义宏，eg：<code>gcc -Dlen=20 hello.c</code>，相当于在hello.c的头文件中定义#define len 20</li><li>-Idir：将dir加到头文件的搜索路径中，而且gcc会在搜索标准头文件之前先搜索dir</li><li>-Ldir：将dir加到库文件的搜索路径中，而且gcc会在搜索标准库文件之前先搜索dir</li><li>-llibrary：在链接的时候搜索library库</li><li>-w：禁止输出警告信息</li><li>-Wwarning：设置警告，可以设置的警告开关很多，通常使用-Wall开启所有警告</li></ul><h3 id="2-2-make工具与makefile文件"><a href="#2-2-make工具与makefile文件" class="headerlink" title="2.2 make工具与makefile文件"></a>2.2 make工具与makefile文件</h3><p>make的执行过程：</p><ul><li>读取所有的makefile文件内容，记录所有的变量及其值、隐式或显式的规则，并构造所有目标对象及其先决条件的全景图</li><li>make使用这些内部结构来确定哪个目标对象需要被重建，并且使用相应的规则来操作</li></ul>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;p&gt;Linux学习手册，覆盖常见知识点和常用命令&lt;/p&gt;</summary>
    
    
    
    <category term="Basic" scheme="https://lightship568.github.io/blog/categories/Basic/"/>
    
    
  </entry>
  
  <entry>
    <title>加密算法</title>
    <link href="https://lightship568.github.io/blog/2021/09/12/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"/>
    <id>https://lightship568.github.io/blog/2021/09/12/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/</id>
    <published>2021-09-12T13:04:03.000Z</published>
    <updated>2021-09-23T02:04:42.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>更新中......</code>　　</p><p>常见加密算法总结。<span id="more"></span></p><hr><h2 id="单向散列算法"><a href="#单向散列算法" class="headerlink" title="单向散列算法"></a>单向散列算法</h2><p>　　即Hash算法，是一种将任意长度的消息压缩到都已固定的长度（消息摘要）的函数，该过程不可逆。可用于数字签名、消息完整性检测、消息起源的认证检测等。常见散列算法有MD5、SHA、RIPE-MD、HAVAL、N-Hash等。</p><h3 id="1-MD5"><a href="#1-MD5" class="headerlink" title="1.MD5"></a>1.MD5</h3><p>　　MD5 (Message Digest Algorithm)对输入的任意长度消息进行运算，产生128bits消息摘要。目前由于穷举攻击和密码分析的发展导致MD5已经不那么流行了。</p><ol><li><p>数据填充</p><p>填充消息使其长度与448 mod 512同余（长度 == 448 mod 512），至少填充1位，至多512位。添加首位为1，之后填0。</p></li><li><p>添加长度</p><p>上一步结构之后附上64位消息长度（如果长度大于64位则只是用低64位），最终消息的长度正好是512的整数倍。</p></li><li><p>初始化变量</p><p>用四个32位寄存器A、B、C、D来计算消息摘要。初始化值固定：</p><ul><li>A = 01234567H</li><li>B = 89ABCDEFH</li><li>C = FEDCBA98H</li><li>D = 76543210H</li></ul><p>由于内存是小端序，因此若直接赋值在内存中，需要注意初始值，如A = 67452301H。最后使内存按顺序增减即可。</p></li><li><p>数据处理</p><p>辅助函数：</p><ul><li>F(X,Y,Z) = (X&amp;Y) | ((~X)&amp;Z)</li><li>G(X,Y,Z) = (X&amp;Z) | (Y&amp;(~Z))</li><li>H(X,Y,Z) = X^Y^Z</li><li>I(X,Y,Z) = Y^(X | (~Z))</li></ul><p>利用上面的四种辅助函数操作，生成四个重要的计算函数。首先我们声明四个中间变量a,b,c,d，赋值：a = A, b = B, c = C, d = D。然后定义这四个计算函数为：</p><ul><li>FF(a, b, c, d, M[j], s, ti)表示 a = b + ((a + F(b, c, d) + Mj + ti) &lt;&lt;&lt; s)</li><li>GG(a, b, c, d, M[j], s, ti)表示 a = b + ((a + G(b, c, d) + Mj + ti) &lt;&lt;&lt; s)</li><li>HH(a, b, c, d, M[j], s, ti)表示 a = b + ((a + H(b, c, d) + Mj + ti) &lt;&lt;&lt; s)</li><li>II(a, b, c, d, M[j], s, ti)表示 a = b + ((a + I(b, c, d) + Mj + ti) &lt;&lt;&lt; s)</li></ul><p>其中M[j]表示消息的第j个子分组（从0到15），&lt;&lt;表示循环左移s，常数ti是4294967296*abs(sin(i))的整数部分，i取值从1到64，单位是弧度。</p><p>然后执行循环，次数为组数（每组512bits），每次64步计算，每个计算函数依次执行16次。</p></li><li><p>输出</p><p>运算完毕后ABCD的顺序级联则是MD5散列的结果。</p></li></ol><h3 id="2-SHA"><a href="#2-SHA" class="headerlink" title="2.SHA"></a>2.SHA</h3><p>　　安全散列算法 (Secure Hash Algorithm, SHA)，包括SHA-1，SHA-256、SHA-384和SHA-512共四种，分别产生160位、256位、384位和512位的散列值。下面以SHA-1为例。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;code&gt;更新中......&lt;/code&gt;　　&lt;/p&gt;
&lt;p&gt;常见加密算法总结。&lt;/p&gt;</summary>
    
    
    
    <category term="Reverse" scheme="https://lightship568.github.io/blog/categories/Reverse/"/>
    
    
  </entry>
  
  <entry>
    <title>操作系统概述</title>
    <link href="https://lightship568.github.io/blog/2021/08/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"/>
    <id>https://lightship568.github.io/blog/2021/08/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/</id>
    <published>2021-08-29T07:16:36.000Z</published>
    <updated>2021-09-10T11:37:48.000Z</updated>
    
    <content type="html"><![CDATA[<hr><p><code>建设中，未完待续</code></p><h2 id="操作系统引论"><a href="#操作系统引论" class="headerlink" title="操作系统引论"></a>操作系统引论</h2><hr><h3 id="1-发展过程"><a href="#1-发展过程" class="headerlink" title="1.发展过程"></a>1.发展过程</h3><ol><li><strong>无操作系统</strong>：人工、脱机输入/输出</li><li><strong>单道批处理系统</strong></li><li><strong>多道批处理系统</strong></li><li><strong>分时系统</strong><span id="more"></span><ul><li>多路性</li><li>独立性</li><li>及时性</li><li>交互性</li></ul></li><li><strong>实时系统</strong><ul><li>多路性</li><li>独立性</li><li>及时性</li><li>交互性</li><li>可靠性</li></ul></li><li><strong>微机操作系统</strong></li></ol><h3 id="2-基本特征"><a href="#2-基本特征" class="headerlink" title="2.基本特征"></a>2.基本特征</h3><ul><li><strong>并发性</strong></li><li><strong>共享性</strong></li><li><strong>虚拟性</strong></li><li><strong>异步性</strong></li></ul><h3 id="3-功能"><a href="#3-功能" class="headerlink" title="3.功能"></a>3.功能</h3><ol><li><strong>处理机管理</strong>：在传统操作系统中， 处理机的分配和运行都是以进程为基本单位，因此通常将处理管理归结为对进程的管理。<ul><li>进程控制</li><li>进程同步</li><li>进程通信</li><li>进程调度</li></ul></li><li><strong>储存器管理</strong><ul><li>内存分配</li><li>内存保护</li><li>地址映射</li><li>内存扩充</li></ul></li><li><strong>设备管理</strong><ul><li>缓冲管理</li><li>设备分配</li><li>设备处理</li></ul></li><li><strong>文件管理</strong><ul><li>文件储存空间的管理</li><li>目录管理</li><li>文件的读/写管理和保护</li></ul></li><li><strong>友好的用户接口</strong><ul><li>用户接口</li><li>程序接口</li></ul></li><li><strong>现代操作系统的新功能</strong><ul><li>系统安全</li><li>网络的功能和服务</li><li>支持多媒体</li></ul></li></ol><h3 id="4-结构设计"><a href="#4-结构设计" class="headerlink" title="4.结构设计"></a>4.结构设计</h3><ol><li>无结构OS</li><li>模块化结构OS</li><li>分层式结构OS</li><li>微内核机构OS</li></ol><h2 id="进程的描述与控制"><a href="#进程的描述与控制" class="headerlink" title="进程的描述与控制"></a>进程的描述与控制</h2><hr><h3 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1.基本概念"></a>1.基本概念</h3><ol><li><p><strong>前趋图</strong></p></li><li><p><strong>程序的顺序执行</strong></p><ul><li>顺序性</li><li>封闭性</li><li>可再现性</li></ul></li><li><p><strong>程序的并发执行</strong></p><ul><li>间断性</li><li>失去封闭性</li><li>不可再现性</li></ul></li><li><p><strong>进程的定义</strong></p><p>至今进程没有一个统一的定义，典型进程定义有如下几种：</p><ul><li>进程是程序的一次执行</li><li>进程是一个程序机器数据在处理机上顺序执行时所发生的活动</li><li>进程是具有独立功能的程序在一个数据集合上运行的过程，他是系统进行资源分配和调度的一个独立单位</li></ul><p>​    引入进程实体概念后，我们可以把传统OS中的进程定义为：“<strong>进程是进程实体的的运行过程，是系统进行资源分配和调度的一个独立单位</strong>”。</p></li><li><p><strong>进程的特征</strong></p><ul><li>动态性</li><li>并发性</li><li>独立性</li><li>异步性</li></ul></li><li><p><strong>进程状态</strong></p><ul><li>就绪</li><li>执行</li><li>阻塞</li></ul><p>​    不少系统中，进程只有上述三种基本状态，但在另一些系统中，又增加了一些新的状态，最重要的是挂起状态：常用于进程对换中，挂起的进程可以腾出内存空间给就绪进程使用；也可以用于调节系统负荷、方便用户考察自己的运行进程或父进程考察子进程、方便操作系统检查运行中的资源使用情况或进行记账等。</p></li><li><p><strong>进程控制块</strong></p><p>​    PCB（Process Control Block）是进程存在的唯一标志。由于PCB要被系统频繁访问，因此PCB中的信息必须全部或者部分长常驻内存。PCB通常包含信息：</p><ul><li>进程标识符</li><li>处理机状态</li><li>进程调度信息</li><li>进程控制信息</li></ul></li></ol><h3 id="2-进程控制"><a href="#2-进程控制" class="headerlink" title="2.进程控制"></a>2.进程控制</h3><ol><li><p>操作系统内核</p><p>​    现代操作系统一般将OS划分为若干层次，再将OS的不同功能，分别设置在不同的层次中。通常将处理机的执行状态分为系统态和用户态两种。</p></li><li><p>进程的创建：使用原语</p></li><li><p>进程的终止：使用原语，实质是回收PCB</p></li><li><p>进程的阻塞和唤醒</p></li><li><p>进程的挂起与激活</p></li></ol><h3 id="3-进程同步"><a href="#3-进程同步" class="headerlink" title="3.进程同步"></a>3.进程同步</h3><ol><li><p><strong>基本概念</strong></p><p>（1）<strong>制约关系</strong></p><ul><li>间接相互制约：互斥</li><li>直接相互制约：同步</li></ul><p>（2）<strong>临界资源和临界区</strong></p><ul><li>访问临界资源的那段代码称为临界区</li><li>进入区与退出区</li></ul><p>（3）<strong>同步机制遵循的规则</strong></p><ul><li>空闲让进</li><li>忙则等待</li><li>有限等待</li><li>让权等待</li></ul></li><li><p><strong>信号量机制</strong></p><ul><li>整型信号量</li><li>记录型信号量</li></ul></li></ol><h3 id="4-经典进程同步问题"><a href="#4-经典进程同步问题" class="headerlink" title="4.经典进程同步问题"></a>4.经典进程同步问题</h3><ol><li>生产者–消费者问题</li><li>哲学家进餐问题</li><li>读者–写者问题</li></ol><h3 id="5-管程机制"><a href="#5-管程机制" class="headerlink" title="5.管程机制"></a>5.管程机制</h3><ol><li><p><strong>定义与特点</strong></p><ul><li>管城内的局部变量只能被局部于管程内的过程所访问，反之亦然，即局部于管程内的过程只能访问管程内的变量和形式参数</li><li>任何进程只能通过调用管程提供的过程入口进入管程</li><li>任一时刻，最多只能有一个进程在管程中执行</li></ul><p>保证进程互斥的进入管程是由编译器负责的，也就是说，管程是一种编程语言的构件，他的实现需要得到编译器的支持。</p></li><li><p><strong>条件变量</strong></p></li><li><p><strong>利用管程解决生产者–消费者问题</strong></p></li></ol><h3 id="6-进程通信"><a href="#6-进程通信" class="headerlink" title="6.进程通信"></a>6.进程通信</h3><ol><li><strong>进程通信类型</strong><ul><li>共享储存器系统</li><li>通道通信</li><li>消息传递系统</li><li>客户机–服务器系统<ul><li>套接字</li><li>远程过程调用和远程方法调用</li></ul></li></ul></li><li><strong>消息缓冲队列通信机制</strong></li></ol><h3 id="7-线程"><a href="#7-线程" class="headerlink" title="7.线程"></a>7.线程</h3><ol><li>概念</li><li>线程的控制</li><li>内核支持线程和用户级线程<ul><li>用户级线程</li><li>内核支持线程</li><li>组合方式</li></ul></li></ol><h2 id="处理机调度与死锁"><a href="#处理机调度与死锁" class="headerlink" title="处理机调度与死锁"></a>处理机调度与死锁</h2><hr><h3 id="1-处理机调度调度层次"><a href="#1-处理机调度调度层次" class="headerlink" title="1.处理机调度调度层次"></a>1.处理机调度调度层次</h3><ul><li>高级调度：作业调度或长程调度，将作业调入内存，分配资源并创建进程。</li><li>低级调度：进程调度或短程调度，决定哪个进程先获得处理机。</li><li>中级调度：内存调度或忠诚调度，实现内存换入换出。</li></ul><h3 id="2-调度算法"><a href="#2-调度算法" class="headerlink" title="2.调度算法"></a>2.调度算法</h3><ol><li>先来先服务（FCFS）</li><li>短作业优先（SJF）</li><li>优先级调度算法（PSA）<ul><li>静态优先权</li><li>动态优先权</li></ul></li><li>高相应比优先（HRRN）：相应比 = 响应时间 / 要求服务时间 = （等待时间+要求服务时间）/ 要求服务时间</li><li>时间片轮转法（RR）</li><li>多级队列调度</li><li>多级反馈队列调度（FB）</li></ol><h3 id="3-实时调度"><a href="#3-实时调度" class="headerlink" title="3.实时调度"></a>3.实时调度</h3><ol><li> 基本条件：截止时间。</li><li> 方式与算法的选择：根据实际情况要求而定。</li><li>常见实时调度算法<ul><li>最早截止时间优先（EDF）</li><li>最低松弛度优先（LLF）</li></ul></li><li> 优先级倒置：防止高优先级进程或线程被低优先级进程或线程延迟或阻塞的现象。</li></ol><h3 id="4-死锁"><a href="#4-死锁" class="headerlink" title="4.死锁"></a>4.死锁</h3><ol><li>原因<ul><li>竞争资源</li><li>进程推进顺序非法</li></ul></li><li>条件<ul><li>互斥条件</li><li>请求与保持条件</li><li>不剥夺条件</li><li>环路等待条件</li></ul></li></ol><h3 id="5-处理死锁基本方法"><a href="#5-处理死锁基本方法" class="headerlink" title="5.处理死锁基本方法"></a>5.处理死锁基本方法</h3><ol><li><p>预防死锁</p><ul><li>摒弃请求与保持：规定所有进程必须一次性申请其在运行过程中所需要的全部资源。</li><li>摒弃不剥夺：提出新资源请求得不到立即满足的进程立即释放已经获得的所有资源（复杂、代价大、反复申请）。</li><li>摒弃环路等待：所有进程严格按照资源号递增顺序申请资源（限制新设备类型增加，进程使用资源顺序与规定不符则造成浪费）</li></ul></li><li><p>避免死锁</p><ul><li>银行家算法</li><li>安全性算法</li></ul></li><li><p>死锁的检测与解除</p><ul><li><p>使用资源分配图简化来检测是否为死锁状态</p></li><li><p>死锁的解除</p><ul><li>剥夺资源</li><li>撤销进程</li></ul><p>处理死锁的每一种方法都需要付出一定的代价，并可能对用户作一些不便的限制，因此还要对死锁视而不见的鸵鸟算法，以求在效率和正确性之间进行折中处理。</p></li></ul></li></ol><h2 id="储器管理"><a href="#储器管理" class="headerlink" title="储器管理"></a>储器管理</h2><hr><h3 id="1-装入"><a href="#1-装入" class="headerlink" title="1.装入"></a>1.装入</h3><ol><li> <strong>绝对装入</strong>（编译时确定物理地址）</li><li> <strong>可重定位装入&amp;静态重定位</strong>（装入时确定物理地址）</li><li> <strong>动态运行时装入</strong>（运行时查找物理地址）</li></ol><h3 id="2-链接"><a href="#2-链接" class="headerlink" title="2.链接"></a>2.链接</h3><ol><li><strong>静态链接</strong>（编译时链接所有模块）</li><li><strong>装入时动态链接</strong>（装入时链接所有模块）</li><li><strong>运行时动态链接</strong>（运行时链接被调用的模块）</li></ol><h3 id="3-连续分配方式"><a href="#3-连续分配方式" class="headerlink" title="3.连续分配方式"></a>3.连续分配方式</h3><ol><li><p><strong>单一连续分配</strong></p></li><li><p><strong>固定分区分配</strong></p></li><li><p><strong>动态分区分配</strong></p><ul><li>首次适应算法：保留高地址较大内存空间，易产生小空闲分区增加系统查找开销。</li><li>循环首次适应算法：形成查找链表，继续上次查找，易缺少大空闲分区。</li><li>最佳适应算法：分区按大小递增排列，分配最适合，但产生的碎片最小，难以利用。</li><li>最坏适应算法：分区按大小递减排列，切分最大空闲分区，易缺少大空间分区。</li></ul><p>为了减少小空闲分区“碎片”，可以在分配时计算分配后剩余空闲空间，若剩余部分低于阈值则不予分配，可减少碎片产生。</p><p>作业运行完毕后要进行内存回收，系统检查是否有空闲分区与回收区相邻，并将之一起合并为一个大的空闲分区，并根据算法将其起始地址或分区大小插入空闲分区表或空闲分区链。</p></li><li><p><strong>伙伴系统</strong>：是固定与动态的折中方案（固定分区限制作业数，并产生内部碎片，动态分区算法复杂，回收需要合并，系统开销大），是将内存空闲分区不断一分为二，如果程序的内存使用刚好使分区不可再分，就将其分配配给程序。回收时只需每次寻找相应伙伴是否空闲即可合并，因此分配需要多次计算，一次回收也可能要进行多次合并。</p></li><li><p><strong>可重定位分区分配</strong>：在动态分区的基础上增加紧凑功能，即找不到足够大的空闲分区、而空闲分区总大小却能满足用户的要求时，对内存空间进行紧凑，要求作业在内存中移动位置，因此也需要的动态重定位技术的支持。</p></li><li><p><strong>分区的保护</strong></p><ul><li>界限寄存器：一对上下限寄存器，也可以是一对基址限长寄存器，地址访问是硬件自动比较，若发生地址越界，产生越界中断</li><li>保护键：为每一个分区分配一个单独的保护键，并且为每个进程分配一个相应的保护键，每当进行内存访问时，程序的键（钥匙）是否匹配分区的键（锁），若不匹配则发生保护性中断。</li></ul></li><li><p><strong>对换</strong>：将内存中暂时不能运行的进程或暂时不用的程序或数据，调用到外存上，以便腾出足够的内存空间，再将具备运行条件的进程或进程所需要的程序和数据调入内存。</p><ul><li>以进程为单位的对换，称为整体兑换或进程对换。这种对换广泛应用于分时系统中。</li><li>以页或段位单位的对换，称为页面对换或分段对换，又称为部分对换，他们是实现虚拟存储器的基础。</li><li>操作系统需要实现：兑换空间管理（提高换入换出速度），进程的换入，进程的换出。</li></ul></li></ol><h3 id="4-基本分页储存管理方式"><a href="#4-基本分页储存管理方式" class="headerlink" title="4.基本分页储存管理方式"></a>4.基本分页储存管理方式</h3><p>　　可重定位分区分配的每次紧凑都是有代价的，会导致内存在较长一段时间内无法使用，引用分页出从后，可以将作业离散地存放在内存中，从而使系统无需紧凑，很好的解决了外部碎片问题，但是也会产生页内碎片。</p><ul><li>注意：这种常规的分页储存管理方式中，整个内存只有有一张页表，不同于虚拟内存技术。</li></ul><ol><li><strong>基本方法</strong>：将进程逻辑地址空间分成若干大小相等的页，将内存分成若干个与页相同大小的块，称为物理块或页框。内存分配以块为单位，页面大小通常设置位2的幂，宏观上就是将原有的逻辑地址分为了两部分，高地址成为页号，低地址成为页内的位移量（或页内地址），程序访问内存时在页表中寻找页框（实际的物理块号），加上页内偏移得到实际物理地址。<ul><li>理论上程序可以使用全部内存，因此每一个进程都需要拥有一个映射全部内存的页表，独一无二的页表实现了逻辑地址的任意性，而且页表必须是连续的，否则会增加查找页表的开销。</li></ul></li><li><strong>地址变换</strong>：逻辑地址到物理地址的转换实在进程执行的过程中由硬件地址变换机构借助于页表自动实现的。通常是页表寄存器读入PCB中页表的内存起始位置和页表长度，当进程要访问某个逻辑地址中的指令后数据时，地址变换机构自动地将逻辑地址分为页号和页内地址两部分，并将页号与页表寄存器中的页表长度进行比较，若页号不小于页表长度，便产生越界中断，否则便以页号检索页表，从中得到物理块号拼接页内地址形成物理地址。<ul><li>上面叙述的越界中断是指一个内存只有一张页表，并未引入虚拟内存概念。</li></ul></li><li><strong>快表</strong>：一级页表结构下读一次内存需要先访问一次页表才能找到物理内存，由于页表也放在内存中，因此每次都要访问两次内存。因此增加一个具有并行查找能力的高速缓冲寄存器，又称联想储存器或快表（TLB，Translation lookaside buffer），用于存放当前被频繁访问的页面的页号和对应的页表项。地址转换时，先并行查找快表中是否由存有该页对应的物理块号，没有则再到内存读页表，将性的页表项于页号一起装入到快表中，若快表已满，则还需要根据置换算法淘汰某个快表项，以装入新的内容。<ul><li>成本原因导致快表一般只能存放61~1024个页表项，如果快表的命中率时a，访问一次内存的时间为t，访问快表的时间为k，则通过逻辑地址访问内存的有效访问时间为：<code>a*k + (1-a)(t+k) + t</code>。</li><li>程序的局部性使得快表的命中率可高达90%，因此可将快表造成的速度损失减少到10%以下。</li></ul></li><li><strong>多级页表</strong>：由于页表支持的物理内存地址很大（32bits -&gt; 4G，64bits -&gt; 16777216T），整张页表也会非常大，找到一个连续完整的大块内存比较困难，因此采用多级页表原理，本质是将页表离散储存在内存中，通过外层页表引用，便可以将内层页表分散的储存在内存中。虚拟存储器技术由于是一个作业一张表的原理，页表的占用的空间大大增多，因此未加使用内层页表可以不储存在内存中，由于外层页表的存在，整张页表仍然是连续的且完整的，一旦访问了不存在的内层页表，再将其移入内存中即可。<ul><li>宏观上多级页表就是将逻辑地址多分了几个部分，分别存放多级列表，现在的64位机器都会有很多级页表的存在。</li><li>访问多级页表必然会增加内存访问次数，降低访问时间，除了使用快表外，本质上还是一种时间换空间的做法。</li></ul></li></ol><h3 id="5-分段式储存管理方式"><a href="#5-分段式储存管理方式" class="headerlink" title="5.分段式储存管理方式"></a>5.分段式储存管理方式</h3><p>　　分页系统虽能较好的解决动态分区的碎片问题，却难以满足用户对段的需要，也不方便支持动态链接技术，因此引入分段式储存管理方式。</p><ol><li><strong>基本原理</strong>：与分页储存相同，只不过将分配对象由整个程序变为段。分段系统将每一个用户程序分成若干个段，包含段名段长，都采用首地址位0的一段连续地址空间，并且使用段表来储存该段在内存中的起始地址（又称为基址）和段的长度以及对应分段进行保护的存取控制信息。地址变换还是采用一个段表寄存器，用于存放正在执行进程的段表起始地址和长度（这里的常规分段式储存管理是直接布置在内存中的，因此会有越界中断）<ul><li>与一级分页系统一样，每访问一个数据也需要访问两次内存，因此分段系统也要使用快表来提高访问的速度。</li></ul></li><li><strong>分页与分段比较</strong>：分页系统和分段系统有许多相似之处，比如：都采用离散分配方式来提高内存利用率，都要通过地址变换机构来实现地址变换。但在概念上两者是完全不同的，它们的区别主要表现在以下三个方面：<ul><li>页是信息的物理单位，分页是为了提高内存的利用率。段则是信息的逻辑单位，它含有一组其意义相对完整的信息。分段是为了能更好地满足用户的需要。</li><li>页的大小固定且由系统决定。段的长度不固定，且由用户所编写的程序决定。</li><li>分页的地址空间是一维的，程序员只需利用一个记忆符，便可表示一个地址。分段的地址空间是二维的，程序员在标识一个地址时，既需给出段名，又需给出段内地址。</li></ul></li><li><strong>段页式储存管理方式</strong>：将地址空间中的用户程序分成若干个段，再将每个段分为若干个页，进行地址变换时，首先通过段表寄存器中的段表起始地址和逻辑地址中的段号找到对应的段表项，从中获得该段的页表起始地址，然后再利用页表起始地址和段内页号来获得对应的页表项，从中获取该页的内存块号，与业内地址拼接成物理地址。<ul><li>每次存取都需要三次访问内存，所以可在地址变换机构中增设快表，用来存放当前被频繁访问的页面所对应的段号、段内页号和物理块号等信息。</li></ul></li></ol><h3 id="6-信息共享"><a href="#6-信息共享" class="headerlink" title="6.信息共享"></a>6.信息共享</h3><p>　　分页系统通过将共享页对应的页表项指向同一个内存块来实现信息共享，但是由于分页由系统自动进行，会造成共享代码或数据与非共享代码或数据共处一页的情况，是其信息共享十分困难。而分段由于具有相对完整的意义，因此可以通过共享段更容易的实现信息共享。</p><h2 id="虚拟存储器"><a href="#虚拟存储器" class="headerlink" title="虚拟存储器"></a>虚拟存储器</h2><hr><h3 id="1-引入"><a href="#1-引入" class="headerlink" title="1.引入"></a>1.引入</h3><ol><li>常规存储管理方式的特征：<ul><li><strong>一次性</strong>（作业必须再运行前一行全部装入内存才能开始运行）</li><li><strong>驻留性</strong>（许多再程序运行中不用或暂时不用的程序或数据占据大量的内存空间，使得一些需要运行的程序无法装入内存；若一个程序要求的内存空间超过了内存实际容量，则该程序必定无法装入内存运行）</li></ul></li><li>由于程序局部性原理，可以引入虚拟储存器：<ul><li><strong>时间局部性</strong>（程序的循环操作）</li><li><strong>空间局部性</strong>（程序的顺序执行）</li></ul></li></ol><h3 id="2-虚拟储存器的主要特征"><a href="#2-虚拟储存器的主要特征" class="headerlink" title="2.虚拟储存器的主要特征"></a>2.虚拟储存器的主要特征</h3><ol><li><strong>多次性</strong>：虚拟储存器将一个作业分成多次调入内存，这也是虚拟存储器最重要的特征。</li><li><strong>对换性</strong>：作业运行期间，虚拟存储器允许将那些暂不使用的程序或数据从内存调至对换区，待以后需要时再调入内存，有效提高内存利用率。</li><li><strong>虚拟性</strong>：虚拟存储器对内存的扩充是逻辑上的，用户所看到的大容量是虚拟的，虚拟性是实现虚拟存储器的目标。</li></ol><ul><li><strong>所需支持</strong>：系统必须具有一定容量的内存和较大容量的外存，必须提供请求分页（段）的页（段）表机制，以及缺页（段）中断机构和地址变换机构；还需要实现请求调页（段）的软件以及实现页（段）置换的软件的支持。</li></ul><h3 id="3-页表结构"><a href="#3-页表结构" class="headerlink" title="3.页表结构"></a>3.页表结构</h3><ul><li><strong>内存块号</strong></li><li><strong>状态位 P</strong>（中断位，存在位，驻留位）：指示该页是否已调入内存</li><li><strong>访问字段 A</strong>：记录最近一段时间被访问次数或未被访问时间，用于置换算法实现</li><li><strong>修改位 M</strong>：表示该页再调入内存后是否被修改过，换出时确定是否重新写回外存</li><li><strong>外存地址</strong>：用于从外存调入页面</li></ul><h3 id="4-过程与策略"><a href="#4-过程与策略" class="headerlink" title="4.过程与策略"></a>4.过程与策略</h3><p>访问未调入内存的页，产生缺页中断，缺页中断程序检查是否有空闲的内存块，有则直接调入，无则根据置换算法淘汰内存中的某一页，若被淘汰的页已被修改过，需要重新写回外存。</p><ul><li><strong>固定分配局部置换策略</strong>：为进程分配固定数量的物理块，换入换出只能在这部分物理块上实现，未考虑进程的动态性。</li><li><strong>可变分配全局置换策略</strong>：先分配一定数量的物理块，缺页时可以全局分配新的物理块，因此置换可能导致其他进程的缺页率增加。</li><li><strong>可变分配局部置换策略</strong>：缺页时只能换出自己的内存页，若缺页率超过阈值，则再分配附加物理块，直到缺页率减少的适当程度为止，反之缺页率特别低的进程可以适当减少分配给他的物理块。因此可获得较高的内存利用率，同时又能保证每个进程有较低的缺页率。</li></ul><h3 id="5-调页策略"><a href="#5-调页策略" class="headerlink" title="5.调页策略"></a>5.调页策略</h3><ol><li><strong>请求调页策略</strong>：正常的调页流程，效果是进程在刚启动时，缺页中断会发生的比较频繁，由于程序访问的局部性，一段时间后缺页率会降至较低。一个被整体换出的进程重新开始执行时，也具有上述情况。</li><li><strong>预调页策略</strong>：预计在不久之后便会访问到的几个页面并将其预先调入内存的策略。预测的难度高，成功率只有50%，因此主要应用于进程首次调入和整体换入时，由程序员或系统指出应该先调入哪些页面，这样可以使得刚开始执行的进程缺页率明显降低。</li></ol><h3 id="6-置换算法"><a href="#6-置换算法" class="headerlink" title="6.置换算法"></a>6.置换算法</h3><ul><li><strong>抖动</strong>：在虚存中，页面在内存与外存之间频繁调度，以至于调度页面所需时间比进程实际运行的时间还多，此时系统效率急剧下降，甚至导致系统崩溃。这种现象称为颠簸或抖动**</li></ul><ol><li><strong>最佳（OPT, Optimal）</strong>：选择以后不再使用或最长时间内不再被访问的内存页面予以淘汰。这是一个理论上的算法，常用来评价其他算法的优劣。</li><li><strong>先进先出（FIFO, First In First Out）</strong>：与程序的局部性不相符，实际应用很少使用纯粹的FIFO。</li><li><strong>最近最久未使用（LRU, Least Recently Used）</strong>：LRU赋予每一个页面一个访问字段，记录相应页面自上次被访问以来所经历的时间，淘汰时选择时间最长的页面，但是为了快速判断哪一页是最近最久未用的页面，他需要较多的硬件支持，增加系统成本，故实际应用中，大多数只采用LRU的近似算法。<ul><li>Clock算法：置被访问页的访问位为1，然后从该页开始扫描，若访问页为1，置为0，若为0，则直接换出。考虑到重写磁盘成本，因此可以选择首个访问位和修改位均为0（0，0）的页面换出，若无可以进行二次扫描选择（0，1）的页面换出。可以重复进行扫描。</li></ul></li><li><strong>最少使用（LFU, Least Frequently Used）</strong> ：同理需要得到较多硬件支持，而且对于新调入的页可能因为访问较少而被换出，而另一些页面因为在某个时候被访问多次，即使以后不再使用，也不会马上被淘汰，从而使LFU算法性能不佳，因此并不常用。</li><li><strong>页面缓冲算法（PBA, Page Buffering Algorithm）</strong>：被换出的页面仍然留在内存的空闲块中，所有的空闲块形成一个空闲页面缓冲池，因此发生缺页时，如果能从空闲页面缓冲池找到所缺的页，则直接可将对应的物理块分配给进程而无需启动磁盘I/O，若无，则为缺页分配一个空闲块并将所缺的页读入其中；同时按照某种置换算法选择一个淘汰页，，该淘汰也所占用的内存块被作为空闲块，加入到空闲页面缓冲池。有的系统如VAX/VMS，还根据淘汰也是否需要写回磁盘将空闲块组织成空闲页面量表和修改页面链表，每次分配内存块时总是将空心啊页面面链表中的第一个物理块分配出去，而当修改页面链表的空闲块达到一定数量时，再将其一起写回磁盘，以减少磁盘I/O次数，提高系统效率。</li></ol><h3 id="7-请求分段储存管理方式"><a href="#7-请求分段储存管理方式" class="headerlink" title="7.请求分段储存管理方式"></a>7.请求分段储存管理方式</h3><p>​    当然虚拟内存也支持请求分段的管理方式，与请求分页系统类似，在分段的基础上增加请求调段功能和段置换功能，便可形成具有虚拟存储器功能的请求分段系统。也可通过建立共享段表使系统分配同一个物理地址来实现分段共享。当然也需要进行分段的保护，常用如越界检查、存取控制检查、环保护机制的方法实现分段保护</p><h3 id="8-段页结合的实际内存管理"><a href="#8-段页结合的实际内存管理" class="headerlink" title="8.段页结合的实际内存管理"></a>8.段页结合的实际内存管理</h3><p>​    <strong>虚拟内存</strong>：我们让应用程序分为段，然后映射到一段虚拟内存中，再让虚拟内存映射到物理内存中的页中，这样就完成了段和页的结合。</p><p>使用内存分为五步：</p><ul><li>分配段</li><li>建段表</li><li>分配页</li><li>建页表</li><li>重定位</li></ul><h2 id="输入输出系统"><a href="#输入输出系统" class="headerlink" title="输入输出系统"></a>输入输出系统</h2><hr><p>​    I/O系统是用于实现数据输入、输出和存储的系统，最主要的任务是完成用户提出的I/O请求、提高I/O速率以及改善设备的利用率，并为更高层的进程方便地使用I/O设备提供手段。</p><h3 id="1-基本功能"><a href="#1-基本功能" class="headerlink" title="1.基本功能"></a>1.基本功能</h3><ol><li><strong>隐藏物理设备的细节</strong>：I/O设备不仅种类繁多，而且它们的特性和操作方式往往也存在很大差异，为了方便用户使用I/O设备，I/O系统必须对I/O设备进行适当的抽象，以隐藏掉物理设备的实现细节，而统一向用户提供少量的、抽象的读/写命令。</li><li><strong>与设备的无关性</strong>：允许应用程序通过抽象的逻辑设备名来请求使用某类设备，使得应用程序独立于具体使用的物理设备，从而有效地提高OS的可移植性和易适应性。</li><li><strong>提高处理机和I/O设备的利用率</strong>：应尽量减少处理机对I/O设备的干预，提高处理机和I/O设备并行操作的程度，以提高它们的利用率。</li><li><strong>对I/O设备进行控制</strong>：通过设备驱动程序启动I/O设备进行数据传输，并能对数据传输方式进行有效的控制。</li><li><strong>确保对设备的正确共享</strong>：对不同类型的设备应采用不同的分配方式，以保证多个进程能共享设备进行正确的I/O操作。</li><li><strong>错误处理</strong>：相对于系统的其他部分，I/O设备运行时更容易出现错误，而且这些错误很多是与设备紧密相关的，因此对于这类错误，应该尽可能在接近硬件的层面上处理，只有低层软件解决不了的错误才需向上层报告，请求上层软件解决。</li></ol><h3 id="2-层次结构"><a href="#2-层次结构" class="headerlink" title="2.层次结构"></a>2.层次结构</h3><ol><li>用户层I/O软件</li><li>设备独立性软件</li><li>设备驱动程序</li><li>中断处理程序</li></ol><h3 id="3-I-O硬件"><a href="#3-I-O硬件" class="headerlink" title="3.I/O硬件"></a>3.I/O硬件</h3><ol><li><p><strong>I/O设备</strong></p><ul><li>按信息交换的单位分类：块设备（速度高可寻址）、字符设备（速度低不可寻址）</li><li>按使用特性分类：储存设备、I/O设备</li><li>按传输速率分类：低速设备、中速设备、高速设备</li></ul></li><li><p><strong>设备控制器</strong></p><p>​    设备控制器是CPU和I/O之间的硬件接口，他接收从CPU发来的命令。并去控制一个或多个设备，在微型机和小型机中，他通常是一块可以插入主板扩展槽的印刷电路板，也叫接口卡。</p><p>​    设备控制器通过一组寄存器来沟通CPU和I/O，CPU通过向其中的控制寄存器写命令来执行I/O操作，如果某个命令带有参数，则还需要将这些参数写道控制器的相应寄存器中。接收到命令后，设备控制器将按命令的要求独立的去控制指定的设备的输入/输出，CPU便可去执行其他工作。输入/输出的完成情况与设备的状态信息均由控制器存放在自己的状态寄存器中，当控制器完成与设备之间的数据交换后，他将产生一个中断。CPU可通过读取寄存器来获得操作结果和设备的状态。</p><p>​    为了平衡速度差距，控制器中须设置一些数据缓冲寄存器，用于缓冲CPU向外的输出和IO向内的输入。</p></li><li><p><strong>I/O寄存器的访问方式</strong></p><ul><li><strong>I/O端口号</strong>：使用I/O指令来读写设备控制器内的寄存器。</li><li><strong>内存映射I/O</strong>：I/O寄存器作为内存地址空间的一部分，该地址不会被分配给内存单元，可以采用与访问内存同样的方式来访问I/O寄存器。</li></ul></li><li><p><strong>I/O通道</strong></p><p>​    在许多大、中型计算机系统中，I/O管理工作交给了一个专门的部件，即I/O通道。其作为一个独立于主机CPU的专门用来管理I/O的特殊处理机，有着自己的指令系统，其指令称为通道指令。通道指令主要局限于与I/O操作相关的指令，通道所执行的程序被称为通道程序，由于通道不带内存，故通道程序被存放在主机的内存中。通道有自己的总线控制部分，可以控制设备与内存直接进行数据交换。</p></li></ol><h3 id="4-中断及中断处理程序"><a href="#4-中断及中断处理程序" class="headerlink" title="4.中断及中断处理程序"></a>4.中断及中断处理程序</h3><ol><li><p><strong>中断</strong></p><p>​    中断是指CPU在执行一个程序时，对系统中发生的某个事件作出的一种反应：CPU暂停正在执行的程序，保留现场后自动转去处理相应的事件，处理完该事件后，到适当的时候返回断点，继续完成被打断的程序。中断在操作系统中有着重要的地位，它是多道程序得以实现的基础。<br>​    根据引起中断的事件的不同类型，可将中断分为外部中断（简称中断）和陷入（又叫异常）两种，前者是由CPU以外的外部事件引起的，如I/O设备引起的I/O中断；后者是CPU执行指令过程中检测到的一些内部事件引起的，如非法指令、地址越界等引起的中断。<br>​    每一种中断或陷入都有一个与之相联系的中断号，并有一个与之相联系的中断处理程序，CPU通过执行相应的中断处理程序来完成对应事件的处理。为了处理上的方便，每种中断或陷入的中断处理程序按中断号的顺序存放在一张中断向量表或中断描述符中。在中断响应时，系统会根据中断号去查找中断向量表或中断描述符表，从中获得相应的中断向量表处理程序的入口地址，这样便可以转入中断处理程序执行。</p></li><li><p><strong>I/O中断处理程序工作流程</strong></p><p>（1）<strong>检查本次I/O操作的完成情况</strong>：中断处理程序通过读设备控制器的状态寄存器来检查本次/O操作的完成情况。<br>（2）<strong>进行I/O结束或错误处理</strong>：若本次操作成功，则进行结束处理。譬如，本次操作是字符设备的读操作，即中断来自某个进行输入的字符设备，那说明该设备已经读入了一本字符（字）的数据，并已将该数据放入数据寄存器中。此时中断处理程序应将该数据传送给CPU，再将它存入缓冲区中，并修改相应的缓冲区指针，使其指向下一个内存单元。否则，根据发生异常的原因做相应的处理，在某些情况下，还需要按重试次数调用设备驱动程序重新传送数据。I/O执行的最终结果，也将由中断处理程序向上层软件汇报。<br>（3）<strong>唤醒被I/O操作阻塞的进程</strong>：I/O中断处理程序还必须唤醒等待本次I/O完成的相应进程，以使它能继续向前推进。<br>（4）<strong>启动下一个请求</strong>：若请求I/O的队列中还有其他I/O请求等待处理，则调用设备驱动程序进行新一轮的数据传送。<br>（5）<strong>中断返回</strong>：执行中断返回指令进行中断返回。</p></li></ol><h3 id="5-设备驱动程序"><a href="#5-设备驱动程序" class="headerlink" title="5.设备驱动程序"></a>5.设备驱动程序</h3><p>设备驱动程序是I/O进程与设备控制器之间的通信程序，它接收来自上层软件的、抽象的I/O命令，再把它转换成具体要求后，发送给设备控制器，从而启动设备进行数据传送。设备驱动程序的处理过程如下：<br>（1）<strong>将抽象要求转换成具体要求</strong>：操作系统对用户屏蔽了有关物理设备的具体细节，并提供给用户一个一致的I/O接口，因此，用户进程或上层软件发出的I/O请求通常只是一些抽象的命令，驱动程序必须将这些命令按设备控制器所要求的格式转换成具体的命令，如将read命令中的盘块号按地址寄存器的格式转换成盘面、磁道及扇区号。<br>（2）<strong>检查I/O请求的合法性</strong>：每种设备都只能完成一组特定的功能，设备驱动程序必须检查用户提出的I/O请求，若相应设备不支持这次I/O请求，则认为这次I/O请求非法。对某些设备，如磁盘上的文件操作，若它们的打开方式是读，则认为用户的写请求是非法的，因此必然被拒绝。<br>（3）<strong>读出和检查设备的状态</strong>：在启动设备之前，驱动程序要从设备控制器的状态寄存器中读出设备的状态，仅当它处于就绪状态时，才能启动其设备控制器，否则只能将相应的I/O请求插入请求I/O的队列。<br>（4）<strong>传送必要的参数</strong>：对带有参数的I/O命令，驱动程序必须将这些参数，如读盘时的磁盘地址、内存地址、本次要传送的字节数等，传送到设备控制器的相应寄存器中。对于字符设器，若发出的是写命令，驱动程序还必须把输出数据写入控制器的数据寄存器。有些设备可具有多种工作方式，典型的情况是利用RS-232接口进行异步通信，在启动该接口之前应该先按通信规程设定下述参数：波特率、奇偶校验方式、停止位数及数据字节长度等。<br>（5）<strong>启动I/O设备</strong>：在完成上述各项准备工作后，驱动程序可以向控制器的命令寄存器传送相应的命令，启动I/O设备开始I/O操作。</p><ul><li>驱动设备发出I/O命令后，基本的I/O操作是在设备控制器的控制下进行的。通常I/O操作所要完成的工作需要一定的时间，因此执行驱动程序的进程便把自己阻塞起来，直到I/O中断到来时才被唤醒。</li></ul><h3 id="6-I-O控制方式"><a href="#6-I-O控制方式" class="headerlink" title="6.I/O控制方式"></a>6.I/O控制方式</h3><ol><li><strong>轮询</strong></li><li><strong>中断</strong></li><li><strong>直接存储器访问（DMA）</strong></li><li><strong>I/O通道控制</strong></li></ol><h3 id="7-与设备无关的I-O软件"><a href="#7-与设备无关的I-O软件" class="headerlink" title="7.与设备无关的I/O软件"></a>7.与设备无关的I/O软件</h3><ol><li><p>概念：应用程序与具体使用的物理设备无关。设置LUT逻辑设备表，应用程序按逻辑设备名称来请求使用某类设备。</p></li><li><p>设备独立性软件：在设备驱动程序之上设置的一层软件，首先是执行所有设备的公共操作，包括：缓冲管理、差错控制、对独立设备的分配和回收、提供独立于设备的逻辑数据块、逻辑设备到物理设备的映射、设备的保护等；其次是向用户层软件提供一个设备驱动程序的统一接口。</p></li><li><p>设备分配</p><p>（1）<strong>设备分配中的数据结构</strong></p><ul><li><strong>设备控制表（DCT）</strong>：每个设备有一张DCT，用于记录相应设备的各种属性，包含设备类型、设备标识符、设备状态、设备等待队列指针、与设备连接的控制器的COCT指针、重复执行次数等。</li><li><strong>控制器控制表（COCT）</strong>：用于记录控制器情况</li><li><strong>通道控制表（CHCT）</strong>：用于记录通道情况</li><li><strong>系统设备表（SDT）</strong>：每个设备占SDT的一个表目，包含设备类型、设备表示符、设别控制表指针与设备驱动程序入口地址等。</li></ul><p>（2）<strong>独占设备的分配程序</strong></p><ul><li>当某进程提出I/O请求后，设备分配程序首先根据进程给出的物理设备名，查找SDT，从中找到该设备的DCT；在检查DCT中的设备状态字段，若设备处于忙状态，则将请求I/O的进程插入设备等待队列；否则便按照一定的算法来计算本次设备分配的安全性，若分配不会导致系统进入不安状态，便将该设备分配给请求进程，否则仍将该进程插入设备等待队列。</li><li>设备分配成功后，设备分配程序将通过DCT找到与该设备相连接的控制器的COCT，检查COCT的状态字段，若控制器忙，不变将球球进程插入扣扣内阁制其等待队列；否则便将该控制器分配给请求进程。</li><li>分配控制器后，通过COCT又可以i找到与该控制器连接的通道的CHCT，进行通道的分配，只有在设备、控制器和通道三者都分配成功时，这次设备的分配才算成功，然后系统便可启动该设备进行数据传送。</li></ul><p>4.缓冲管理</p><ul><li>可以显著的提高CPU和I/O设备之间的并行操作程度</li><li>引入缓冲区还可以协调传输数据大小不一致的设备，很好的解决数据粒度不匹配的问题</li></ul></li></ol><h3 id="8-用户层的I-O软件"><a href="#8-用户层的I-O软件" class="headerlink" title="8.用户层的I/O软件"></a>8.用户层的I/O软件</h3><ol><li><p><strong>I/O库函数</strong></p></li><li><p><strong>假脱机（SPOOLing）系统</strong></p><ul><li>将一台独占的物理设备虚拟为多台逻辑设备，从而使该物理设备可被多个进程同时共享</li></ul><p>（1）<strong>SPOOLing系统组成</strong></p><ul><li><p>输入井和输出井</p></li><li><p>输入缓冲区和输出缓冲区</p></li><li><p>输入进程和输出进程</p></li><li><p>井管理程序</p></li></ul><p>（2）<strong>假脱机打印系统</strong></p><ul><li>利用SPOOLing技术可将独占的打印机改造为一台共多个用户共享的设备，这种共享打印机技术已被广泛的用于多用户系统和局域网络中。</li><li>相应操作：在输出井中位置申请一个空闲的磁盘块区，并将要打印的数据送入其中；位用户进程申请一张空白的用户请求打印表，并将用户的阿银要求填入其中，让后将该表挂到假脱机文件队列上。</li></ul></li></ol><h3 id="9-磁盘调度"><a href="#9-磁盘调度" class="headerlink" title="9.磁盘调度"></a>9.磁盘调度</h3><ul><li>磁盘实际访问时间由<code>寻道时间</code>、<code>旋转延迟时间</code>、<code>传输时间</code>三部分组成。对于大多数磁盘，寻道时间站其中的大部分，所以减少平均寻道时间可以显著的改善磁盘系统的性能。</li><li>磁盘调度<ol><li><strong>先来先服务（FCFS）</strong></li><li><strong>最短寻道时间有限（SSTF）</strong>：每次寻道时间最短并不能保证平均寻道时间最短，而且在当前磁道附近不断有新的I/O请求到来时，还可能使要求访问较远磁道的进程产生饥饿现象。</li><li><strong>扫描（SCAN）</strong>：也叫电梯调度算法，他选中的是当前磁头移动方向上、距离当前磁头所在的磁道最近的磁道上的请求。SCAN算法既能获得较好的寻道性能，又能防止饥饿现象，故广泛用于大中小型机器和网络中。</li><li><strong>循环扫描（CSCAN）</strong>：SCAN磁头移动时，若恰好对越过的磁道进行访问，则必须等待磁头移动到另一端反向回来才可以访问。为了减少这种延时，规定只在磁头移动的某一个方向上处理磁盘请求，因此当沿着该方向访问到最远的一个请求后，磁臂立即返回到磁盘的另一端，并再次开始扫描（说的很高大上，其实就是单方向扫描）</li><li><strong>N-step-SCAN</strong>：当进程对某一磁道有较高的访问频率时，利用前面几个算法都可能出现磁臂停留在磁道上不动的情况，这种现象被称为“磁臂粘着”，N-step-SCAN将磁盘请求队列按请求到达的时间先后顺序分成若干个长度为N的子队列，并采用FCFS算法依次处理这些子队列，而对于每个子队列，则又是按SCAN算法进行处理。</li><li><strong>FSCAN</strong>：实质上是N-step-SCAN的简化，他只把磁盘请求队列分成两个子队列，一个是当前所有请求磁盘I/O的进程形成的队列，由磁盘调度按SCAN算法进行处理；在扫描期间到达的所有请求磁盘I/O的进程，被放入另一个等待处理的请求队列。这样所有的新请求都将被推迟到下一次扫描时处理。</li></ol></li></ul><h2 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h2><hr><h3 id="1-文件和文件系统"><a href="#1-文件和文件系统" class="headerlink" title="1.文件和文件系统"></a>1.文件和文件系统</h3><ol><li><strong>文件的定义</strong>：文件是具有文件名的一组相关信息的集合，通常是由ASCII码+/汉字组成。文件的基本内容可以由零或多个字节构成；这些字节可以是简单的字符流，也可以是一个或多个记录的集合，他们的具体含义由文件的创建者和使用者解释。每个文件除了文件名和基本内容以外，还应具有自己的属性，具体的属性可以包括：文件类型、文件长度、文件的物理位置、文件的建立时间等，他们也必须保存在文件储存器中。</li><li><strong>文件系统模型</strong><ul><li>文件系统的接口</li><li>对对象操作和管理的软件集合</li><li>对象及其属性</li></ul></li><li><strong>文件的使用</strong>：创建、删除、读、写、设置文件的读/写指针、打开、关闭。</li></ol><h3 id="2-文件的逻辑结构"><a href="#2-文件的逻辑结构" class="headerlink" title="2.文件的逻辑结构"></a>2.文件的逻辑结构</h3><ol><li><p><strong>有结构文件</strong></p><p>有结构文件也称记录式文件，其数据的组成可分为数据项、记录和文件三级。</p><ul><li>顺序文件：串结构文件（按存入先后顺序排列）；顺序结构文件（按关键字的次序排列）。一般记录为定长记录，故其通常具有较快额记录检索速度。</li><li>索引文件：当记录为可变长度时，通常采用索引文件的方式，他为每一个文件建立一张索引表，并将主文件的每个记录的记录号（或关键字）、长度和逻辑地址记录在索引表中。由于索引表本身是一个定长记录文件，因此可以十分方便的检索到相应记录的索引表想，从而可方便的对主文件中的记录实现直接存取。</li><li>索引顺序文件：是上述二者结合，记录按顺序方式组织，每个文件也需要建立一张索引表，但是只需要为主文件的每一组记录的第一个记录设置一个索引表项，因此能有效地减少索引表所占的空间。</li></ul></li><li><p><strong>无结构文件</strong></p><p>​    无结构文件是指由字符流构成的文件，故又称流式文件。流式文件的基本单位是字节，因此可以将它看作是记录式文件的一个特例。在很多操作系统中，如UNIX系统，所有的文件都被看成是流式文件。在创建和使用流式文件时，虽然操作系统只讲他看成是一个字符流，但用户仍然可以按自己的需要赋予文件某种结构。</p></li></ol><h3 id="3-文件目录"><a href="#3-文件目录" class="headerlink" title="3.文件目录"></a>3.文件目录</h3><ol><li><p><strong>文件控制块、目录项和索引节点</strong></p><p>​    文件控制块（FCB）是OS用来描述和控制文件的一个数据结构，其中包含文件名、文件物理地址，通常还有文件的逻辑结构、文件的物理结构、文件的长度、存取权限、建立日期和时间、最后一次修改的日期和时间、我呢见的连接计数及文件主标识符等文件属性信息。  </p><p>​    文件控制块与文件一一对应，问及那控制块的有序集合被称为目录，其中每个文件控制块被称为目录项。目录通常也是以稳健的方式存放在外存上，故也被称为目录文件。</p><p>​    有些系统如UNIX系统，便采用把文件和文件描述信息分开的办法，即将文件描述信息单独形成一个称为索引节点的数据结构，存放在外存的索引节点区，而组成问及那目录的目录项中仅有文件名和指向该文件所对应的索引结点的指针。这样，便可以大大减少文件目录所占的磁盘块数，从而加快检索目录的速度。</p></li><li><p><strong>目录结构</strong></p><ul><li>单级目录结构：概念性的东西</li><li>两级目录结构：为多个用户提供单独的用户文件目录</li><li>多级目录结构：又称树形目录结构</li></ul></li><li><p><strong>目录查询技术</strong></p><p>​    目标目录的文件分量词与目录树的每层分别比较，这里不再赘述。</p></li></ol><h3 id="4-文件共享"><a href="#4-文件共享" class="headerlink" title="4.文件共享"></a>4.文件共享</h3><ol><li><strong>基于索引节点的共享方式</strong><ul><li>通过链接计数实现，创建索引指针链接数加一，为零则删除。</li><li>文件主无法直接删除自己的文件。</li></ul></li><li><strong>利用符号链实现文件共享</strong><ul><li>通过建立LINK文件实现，该文件只包含了被链接文件的路径名，一旦访问LINK类型文件将被OS截获，根据文件中的路径名去读那个文件。</li><li>只要简单提供一个机器的网络地址以及文件在该机其中的文件路径名，便可链接全球任一处机器上的文件。</li><li>其他用户访问共享文件必须根据路径中的分量名逐级的去检索目录，加大了访问文件的开销。</li><li>尽管LINK类型文件十分简单，但仍需要为它配置一个索引节点，并分配一个盘块来存放被链接文件的路径名，同样会增加系统开销。</li></ul></li></ol><h3 id="5-文件保护"><a href="#5-文件保护" class="headerlink" title="5.文件保护"></a>5.文件保护</h3><p>​    安全性背景：人为因素、系统因素、自然因素（随时间推移，存放在磁盘上的数据会逐渐消失），先在本章讨论人为因素。</p><ol><li><p><strong>访问权和保护域</strong></p><ul><li>访问权是一个用户（进程）对某个对象执行操作的权利，它可以用一有序对 （对象名、权集）来表示。</li><li>保护域，简称域，是用户（进程）对一组对象的访问权的集合。</li></ul><p>​    进程和域之间的联系可以是静态的，因此在整个生命期中，进程只能在一个域中运行。进程和域之间的联系也可以是动态的，即在进程运行的不同阶段，允许他通过保护域切换功能，从一个域切换到另一个域。</p></li><li><p><strong>访问矩阵</strong></p><p>​    访问矩阵用来描述系统的访问控制的一张二维表，其行代表一个保护域，列代表系统中的一个对象，矩阵中的每一项是由一组访问权组成的，它定义了在行所代表的域中的执行的进程，能对列所代表的对象施加何种操作。若进程和域之间采用动态的联系方式，便可以在矩阵中增加域本身，表示进程是否可以切换到其他域中运行。</p></li><li><p><strong>访问矩阵的实现</strong></p><p>​    由于域的数量和对象的数量都可能很大，需要减少访问矩阵的空间开销和访问该矩阵的时间开销。</p><ul><li>访问控制表：是访问矩阵按列划分去掉空项形成的。其存放在文件对象的文件控制块中，其访问控制表可以作为文件存取控制信息。</li><li>访问权限表：是访问矩阵按行划分形成的。</li></ul><p>​    当一个用户（进程）第一次试图访问一个对象时，必须先检查访问控制表，如果用户（进程）不具有该对象的访问权，则由系统拒绝用户（进程）的访问，并构成一异常事件，否则便允许用户（进程）对该对象进行访问，并在用户（进程）的访问权限表中增加对该对象的访问权限。以后，该用户（进程）便可以直接利用这一返回的权限去访问该对象。</p></li></ol>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;p&gt;&lt;code&gt;建设中，未完待续&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;操作系统引论&quot;&gt;&lt;a href=&quot;#操作系统引论&quot; class=&quot;headerlink&quot; title=&quot;操作系统引论&quot;&gt;&lt;/a&gt;操作系统引论&lt;/h2&gt;&lt;hr&gt;
&lt;h3 id=&quot;1-发展过程&quot;&gt;&lt;a href=&quot;#1-发展过程&quot; class=&quot;headerlink&quot; title=&quot;1.发展过程&quot;&gt;&lt;/a&gt;1.发展过程&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;无操作系统&lt;/strong&gt;：人工、脱机输入/输出&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;单道批处理系统&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;多道批处理系统&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;分时系统&lt;/strong&gt;&lt;/li&gt;&lt;/ol&gt;</summary>
    
    
    
    <category term="Basic" scheme="https://lightship568.github.io/blog/categories/Basic/"/>
    
    
  </entry>
  
  <entry>
    <title>简易汇编入门</title>
    <link href="https://lightship568.github.io/blog/2021/08/24/%E7%AE%80%E6%98%93%E6%B1%87%E7%BC%96%E5%85%A5%E9%97%A8/"/>
    <id>https://lightship568.github.io/blog/2021/08/24/%E7%AE%80%E6%98%93%E6%B1%87%E7%BC%96%E5%85%A5%E9%97%A8/</id>
    <published>2021-08-24T09:25:41.000Z</published>
    <updated>2023-10-29T12:22:06.109Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计组入门"><a href="#计组入门" class="headerlink" title="计组入门"></a>计组入门</h1><hr><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>​    计算机执行时能够理解的只有机器语言，即用“01”表示的代码，而汇编语言，其实是将这种01表示为人类可以记住的字符和数字，它是一种低级语言，可以直接描述/控制 CPU 的运行。如果你想知道计算机如何执行代码、CPU如何工作、高级语言的本质工作、以至于学习二进制，就一定要学习汇编语言。</p><span id="more"></span><p>​    CPU 只负责计算，本身不具备智能。你输入一条指令（instruction），它就运行一次，然后停下来，等待下一条指令。这些指令都是二进制的，称为操作码（opcode），比如加法指令就是00000011。编译器的作用，就是将高级语言写好的程序，翻译成一条条操作码。汇编语言的代码与操作码是一一对应的。通过汇编器，可以将我们所写的汇编代码“翻译”成机器码。同理，使用反汇编器又可以将机器码“翻译”回来，成为可读的汇编代码。</p><p>​    <code>x86</code>泛指一系列基于Intel 8086且向后兼容的中央处理器指令集架构。最早的8086处理器于1978年由Intel推出，为16位微处理器。我们在这里主要讲解<code>x86</code>汇编。</p><p>​    汇编的优点就在于它是对计算机资源的全盘掌控，汇编精细到每一个寄存器、内存单元，可以说写汇编就是控制计算机的本质，也是对计算机部分硬件的充分理解，如操作系统启动是手写汇编。</p><hr><h2 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h2><p>CPU（center process unit）的简化模型是由控制单元、储存单元、运算单元三部分组成。</p><ul><li>简单CPU内部的几个重要部分：<ol><li>PC，程序计数器</li><li>IR，指令寄存器</li><li>寄存器组</li><li>ALU，算数逻辑运算单元</li></ol></li><li>与内存的关系：</li></ul><p><img src="/blog/2021/08/24/%E7%AE%80%E6%98%93%E6%B1%87%E7%BC%96%E5%85%A5%E9%97%A8/markdown\blog\source_posts\简易汇编入门\image-20210815191712564.png" alt="image-20210815191712564"></p><hr><h2 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h2><p>​    我们首先要引入内存模型与寄存器</p><p>​    CPU 本身只负责运算控制，不负责储存大量数据。数据一般都储存在内存之中，CPU 要用的时候就去内存读写数据。但是，CPU 的运算速度远高于内存的读写速度，为了避免被拖慢，CPU 都自带几级缓存（cache），基本上CPU 缓存可以看作是读写速度较快的内存。<code>DRAM</code>用作内存比较多，<code>SRAM</code>用作cache比较多。当然也有诸如<code>DMA（Direct Memory Access，直接存储器访问）</code>之类的技术可以提高CPU的使用效率。</p><p><img src="/blog/2021/08/24/%E7%AE%80%E6%98%93%E6%B1%87%E7%BC%96%E5%85%A5%E9%97%A8/markdown\blog\source_posts\简易汇编入门\image-20210815183743842.png" alt="image-20210815183743842"></p><p>​    从编程上，cache缓存完全由硬件实现，对程序员透明。cache的实现也会通过一些算法提高cache对内存的提速效果，比如为什么大量使用分支结构会降低程序的执行速度，其实就是因为大量使用分支会降低cache的命中率，从而导致CPU存在一部分数据没法从cache读，速度自然下降了。cache作用也仅仅是为了提高一部分内存的访问速度，而且因此在学习汇编时可以忽略cache的存在。</p><p>​    但是，CPU 缓存还是不够快，另外数据在缓存里面的地址是不固定的，CPU 每次读写都要寻址也会拖慢速度。因此，除了缓存之外，CPU 还自带了寄存器（register），用来储存最常用的数据，同时也可以直接对寄存器进行算数逻辑运算。也就是说，那些最频繁读写的数据（比如循环变量），都会放在寄存器里面，CPU 优先读写寄存器，再由寄存器跟内存交换数据。寄存器的数量有限，造价较高，速度很快，可以由CPU直接访问并执行算数和逻辑操作。</p><p><img src="/blog/2021/08/24/%E7%AE%80%E6%98%93%E6%B1%87%E7%BC%96%E5%85%A5%E9%97%A8/markdown\blog\source_posts\简易汇编入门\image-20210815192623733.png" alt="image-20210815192623733"></p><p>​    <code>x86</code>处理器(32 bits)中的寄存器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">8个通用寄存器：EAX、EBX、ECX、EDX、ESI、EDI、ESP、EBP</span><br><span class="line"></span><br><span class="line">1个标志寄存器：EFLAGS</span><br><span class="line"></span><br><span class="line">6个段寄存器：CS、DS、ES、FS、GS、SS</span><br><span class="line"></span><br><span class="line">5个控制寄存器：CR0、CR1、CR2、CR3、CR4</span><br><span class="line"></span><br><span class="line">8个调试寄存器：DR0、DR1、DR2、DR3、DR4、DR5、DR6、DR7</span><br><span class="line"></span><br><span class="line">4个系统地址寄存器：GDTR、IDTR、LDTR、TR</span><br><span class="line"></span><br><span class="line">其他寄存器：EIP、TSC等。</span><br></pre></td></tr></table></figure><p>​    通用寄存器：</p><p><img src="/blog/2021/08/24/%E7%AE%80%E6%98%93%E6%B1%87%E7%BC%96%E5%85%A5%E9%97%A8/markdown\blog\source_posts\简易汇编入门\image-20210810164548176.png" alt="image-20210810164548176"></p><p>​    由于历史的原因，<code>EAX</code>通常用于计算，<code>ECX</code>通常用于循环变量计数，<code>EAX~EDX</code>均称为通用寄存器。<code>ESP</code>和<code>EBP</code>有专门用途，<code>ESP</code>指示栈指针(用于指示栈顶位置)，而<code>EBP</code>则是基址指针（用于指示子程序或函数调用的基址指针）。如图中所示，<code>EAX、EBX、ECX和EDX</code>的前两个高位字节和后两个低位字节可以独立使用，其中两位低字节又被独立分为H和L部分，这样做的原因主要是考虑兼容16位的程序。</p><p>​    写汇编代码时，寄存器名称大小写不敏感</p><h1 id="汇编入门"><a href="#汇编入门" class="headerlink" title="汇编入门"></a>汇编入门</h1><hr><h2 id="寻址"><a href="#寻址" class="headerlink" title="寻址"></a>寻址</h2><p>​    寻址是计算机非常重要的一个核心功能，无论是代码还是数据，都需要通过寻址。数据需要寻址才能移动到寄存器中进行计算，而代码是通过PC寄存器自增寻址，寻找到下一条代码然后继续执行。本质上调用寄存器也是一种寻址。</p><p>​    七大寻址方式：</p><ol><li><p>立即寻址</p><ul><li>操作数就在指令中，作为指令的一部分，跟在操作码后存放在代码段。</li><li><code>mov ax,0102H  </code></li></ul></li><li><p>寄存器寻址</p><ul><li>操作数在寄存器中，指令中指定寄存器号。</li><li>对于8位操作数，寄存器可以是<code>AL,AH,BL,BH,CL,CH,DL,DH</code>。 对于16位操作数，寄存器可以是<code>AX,BX,CX,DX,BP,SP,SI,DI</code>等</li><li><code>mov bx,ax</code></li></ul></li><li><p>直接寻址</p><ul><li>操作数在存储器中，指令直接包含操作数的有效地址。默认段为<code>DS</code>。</li><li><code>mov ax,[1122h]</code></li><li><code>mov es:[1234],al</code></li></ul></li><li><p>寄存器间接寻址</p><ul><li>操作数在存储器中，操作数的有效地址在<code>SI,DI,BX,BP</code>这4个寄存器之一中。在不采用段前缀的情况下， 对于<code>DI,SI,BX</code>默认段为<code>DS</code>,而<code>BP</code>为<code>SS</code>。</li><li><code>mov ah,[bx]</code></li><li><code>mov ah,cs:[bx] </code></li></ul></li><li><p>寄存器相对寻址</p><ul><li>操作数在存储器中，操作数的有效地址是一个基址寄存器(<code>BX,BP</code>)或变址寄存器(<code>SI,DI</code>)的内容加上8位或16位的位移之和。在指令中的8位和16位的常量采用补码表示，8位要被带符号扩展为16位。</li><li>段址默认情况与寄存器间接寻址相同</li><li><code>mov ah,[bx+6]</code></li></ul></li><li><p>基址加变址寻址</p><ul><li> 操作数在存储器中，操作数的有效地址是一个基址寄存器(<code>BX,BP</code>)加上变址寄存器(<code>SI,DI</code>)的内容。如果有<code>BP</code>，则默认段址为<code>SS</code>,否则为<code>DS</code>。</li><li> <code>mov ah,[bx+si]</code></li></ul></li><li><p>相对基址加变址寻址</p><ul><li>操作数在存储器中，操作数的有效地址是一个基址寄存器(<code>BX,BP</code>)和变址寄存器(<code>SI,DI</code>)的内容加上8位或16位的位移之和。如果有<code>BP</code>，则默认段址为<code>SS</code>,否则为<code>DS</code>。</li><li><code>mov ax,[bx+di-2]</code></li><li><code>mov ax,1234h[bx][di]</code></li></ul></li></ol><hr><h2 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h2><ul><li>不为写而为读</li><li>善用汇编文档与搜索引擎</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line">Intel 汇编指令手册</span><br><span class="line">一、数据传输指令</span><br><span class="line">　　它们在存贮器和寄存器、寄存器和输入输出端口之间传送数据.</span><br><span class="line">　　1. 通用数据传送指令.</span><br><span class="line">　　　　MOV　　传送字或字节.</span><br><span class="line">　　　　MOVSX　先符号扩展,再传送.</span><br><span class="line">　　　　MOVZX　先零扩展,再传送.</span><br><span class="line">　　　　PUSH　　把字压入堆栈.</span><br><span class="line">　　　　POP　　把字弹出堆栈.</span><br><span class="line">　　　　PUSHA　把AX,CX,DX,BX,SP,BP,SI,DI依次压入堆栈.</span><br><span class="line">　　　　POPA　　把DI,SI,BP,SP,BX,DX,CX,AX依次弹出堆栈.</span><br><span class="line">　　　　PUSHAD　把EAX,ECX,EDX,EBX,ESP,EBP,ESI,EDI依次压入堆栈.</span><br><span class="line">　　　　POPAD　把EDI,ESI,EBP,ESP,EBX,EDX,ECX,EAX依次弹出堆栈.</span><br><span class="line">　　　　BSWAP　交换32位寄存器里字节的顺序</span><br><span class="line">　　　　XCHG　　交换字或字节.( 至少有一个操作数为寄存器,段寄存器不可作为操作数)</span><br><span class="line">　　　　CMPXCHG 比较并交换操作数.( 第二个操作数必须为累加器AL/AX/EAX )</span><br><span class="line">　　　　XADD　　先交换再累加.( 结果在第一个操作数里 )</span><br><span class="line">　　　　XLAT　　字节查表转换.</span><br><span class="line">　　　　　　　　── BX 指向一张 256 字节的表的起点, AL 为表的索引值 (0-255,即</span><br><span class="line">　　　　　　　　0-FFH); 返回 AL 为查表结果. ( [BX+AL]-&gt;AL )</span><br><span class="line">　　2. 输入输出端口传送指令.</span><br><span class="line">　　　　IN　　　I/O端口输入. ( 语法: IN 累加器, &#123;端口号│DX&#125; )</span><br><span class="line">　　　　OUT　　I/O端口输出. ( 语法: OUT &#123;端口号│DX&#125;,累加器 )</span><br><span class="line">　　　　　输入输出端口由立即方式指定时, 其范围是 0-255; 由寄存器 DX 指定时,</span><br><span class="line">　　　　　其范围是 0-65535.</span><br><span class="line">　　3. 目的地址传送指令.</span><br><span class="line">　　　　LEA　　装入有效地址.</span><br><span class="line">　　　　　例: LEA DX,string　;把偏移地址存到DX.</span><br><span class="line">         P.S: lea(load effective address)，lea指令可以用来将一个内存地址直接赋给目的操作数，例如：lea eax,[ebx+8]就是将ebx+8这个值直接赋给eax，而不是把ebx+8处的内存地址里的数据赋给eax。而mov指令则恰恰相反，例如：mov eax,[ebx+8]则是把内存地址为ebx+8处的数据赋给eax。</span><br><span class="line">         LEA指令具有单时钟周期，执行效率很高，也可实现寄存器相加：lea ebx ,[eax+edx]</span><br><span class="line"></span><br><span class="line">　　　　LDS　　传送目标指针,把指针内容装入DS.</span><br><span class="line">　　　　　例: LDS SI,string　;把段地址:偏移地址存到DS:SI.</span><br><span class="line">　　　　LES　　传送目标指针,把指针内容装入ES.</span><br><span class="line">　　　　　例: LES DI,string　;把段地址:偏移地址存到ES:DI.</span><br><span class="line">　　　　LFS　　传送目标指针,把指针内容装入FS.</span><br><span class="line">　　　　　例: LFS DI,string　;把段地址:偏移地址存到FS:DI.</span><br><span class="line">　　　　LGS　　传送目标指针,把指针内容装入GS.</span><br><span class="line">　　　　　例: LGS DI,string　;把段地址:偏移地址存到GS:DI.</span><br><span class="line">　　　　LSS　　传送目标指针,把指针内容装入SS.</span><br><span class="line">　　　　　例: LSS DI,string　;把段地址:偏移地址存到SS:DI.</span><br><span class="line">　　4. 标志传送指令.</span><br><span class="line">　　　　LAHF　　标志寄存器传送,把标志装入AH.</span><br><span class="line">　　　　SAHF　　标志寄存器传送,把AH内容装入标志寄存器.</span><br><span class="line">　　　　PUSHF　标志入栈.</span><br><span class="line">　　　　POPF　　标志出栈.</span><br><span class="line">　　　　PUSHD　32位标志入栈.</span><br><span class="line">　　　　POPD　　32位标志出栈. </span><br><span class="line">二、算术运算指令</span><br><span class="line">　　　　ADD　　加法.</span><br><span class="line">　　　　ADC　　带进位加法.</span><br><span class="line">　　　　INC　　加 1.</span><br><span class="line">　　　　AAA　　加法的ASCII码调整.</span><br><span class="line">　　　　DAA　　加法的十进制调整.</span><br><span class="line">　　　　SUB　　减法.</span><br><span class="line">　　　　SBB　　带借位减法.</span><br><span class="line">　　　　DEC　　减 1.</span><br><span class="line">　　　　NEC　　求反(以 0 减之).</span><br><span class="line">　　　　CMP　　比较.(两操作数作减法,仅修改标志位,不回送结果).</span><br><span class="line">　　　　AAS　　减法的ASCII码调整.</span><br><span class="line">　　　　DAS　　减法的十进制调整.</span><br><span class="line">　　　　MUL　　无符号乘法.</span><br><span class="line">　　　　IMUL　　整数乘法.</span><br><span class="line">　　　　　以上两条,结果回送AH和AL(字节运算),或DX和AX(字运算),</span><br><span class="line">　　　　AAM　　乘法的ASCII码调整.</span><br><span class="line">　　　　DIV　　无符号除法.</span><br><span class="line">　　　　IDIV　　整数除法.</span><br><span class="line">　　　　　以上两条,结果回送:</span><br><span class="line">　　　　　　　商回送AL,余数回送AH, (字节运算);</span><br><span class="line">　　　　　或　商回送AX,余数回送DX, (字运算).</span><br><span class="line">　　　　AAD　　除法的ASCII码调整.</span><br><span class="line">　　　　CBW　　字节转换为字. (把AL中字节的符号扩展到AH中去)</span><br><span class="line">　　　　CWD　　字转换为双字. (把AX中的字的符号扩展到DX中去)</span><br><span class="line">　　　　CWDE　　字转换为双字. (把AX中的字符号扩展到EAX中去)</span><br><span class="line">　　　　CDQ　　双字扩展.　　(把EAX中的字的符号扩展到EDX中去)</span><br><span class="line">三、逻辑运算指令</span><br><span class="line">　　　  AND　　与运算.</span><br><span class="line">　　　　OR　　　或运算.</span><br><span class="line">　　　　XOR　　异或运算.</span><br><span class="line">　　　　NOT　　取反.</span><br><span class="line">　　　　TEST　　测试.(两操作数作与运算,仅修改标志位,不回送结果).</span><br><span class="line">　　　　SHL　　逻辑左移.</span><br><span class="line">　　　　SAL　　算术左移.(=SHL)</span><br><span class="line">　　　　SHR　　逻辑右移.</span><br><span class="line">　　　　SAR　　算术右移.</span><br><span class="line">　　　　ROL　　循环左移.</span><br><span class="line">　　　　ROR　　循环右移.</span><br><span class="line">　　　　RCL　　通过进位的循环左移.</span><br><span class="line">　　　　RCR　　通过进位的循环右移.</span><br><span class="line">　　　　　以上八种移位指令,其移位次数可达255次.</span><br><span class="line">　　　　　　　移位一次时, 可直接用操作码.　如 SHL AX,1.</span><br><span class="line">　　　　　　　移位&gt;1次时, 则由寄存器CL给出移位次数.</span><br><span class="line">　　　　　　　　如　MOV CL,04</span><br><span class="line">　　　　　　　　　　SHL AX,CL</span><br><span class="line">四、串指令</span><br><span class="line">　         DS:SI　源串段寄存器　:源串变址.</span><br><span class="line">　　　　　　ES:DI　目标串段寄存器:目标串变址.</span><br><span class="line">　　　　　　CX　　　重复次数计数器.</span><br><span class="line">　　　　　　AL/AX　扫描值.</span><br><span class="line">　　　　　　D标志　0表示重复操作中SI和DI应自动增量; 1表示应自动减量.</span><br><span class="line">　　　　　　Z标志　用来控制扫描或比较操作的结束.</span><br><span class="line">　　　　MOVS　　串传送.</span><br><span class="line">　　　　　　( MOVSB　传送字符.　　MOVSW　传送字.　　MOVSD　传送双字. )</span><br><span class="line">　　　　CMPS　　串比较.</span><br><span class="line">　　　　　　( CMPSB　比较字符.　　CMPSW　比较字. )</span><br><span class="line">　　　　SCAS　　串扫描.</span><br><span class="line">　　　　　　把AL或AX的内容与目标串作比较,比较结果反映在标志位.</span><br><span class="line">　　　　LODS　　装入串.</span><br><span class="line">　　　　　　把源串中的元素(字或字节)逐一装入AL或AX中.</span><br><span class="line">　　　　　　( LODSB　传送字符.　　LODSW　传送字.　　LODSD　传送双字. )</span><br><span class="line">　　　　STOS　　保存串.</span><br><span class="line">　　　　　　是LODS的逆过程.</span><br><span class="line">　　　　REP　　　　　　当CX/ECX0时重复.</span><br><span class="line">　　　　REPE/REPZ　　　当ZF=1或比较结果相等,且CX/ECX0时重复.</span><br><span class="line">　　　　REPNE/REPNZ　　当ZF=0或比较结果不相等,且CX/ECX0时重复.</span><br><span class="line">　　　　REPC　　　　　当CF=1且CX/ECX0时重复.</span><br><span class="line">　　　　REPNC　　　　　当CF=0且CX/ECX0时重复.</span><br><span class="line">五、程序转移指令</span><br><span class="line">　　1&gt;无条件转移指令 (长转移)</span><br><span class="line">　　　　JMP　　无条件转移指令</span><br><span class="line">　　　　CALL　　过程调用</span><br><span class="line">　　　　RET/RETF过程返回.</span><br><span class="line">　　2&gt;条件转移指令 (短转移,-128到+127的距离内)</span><br><span class="line">　　　　( 当且仅当(SF XOR OF)=1时,OP1循环控制指令(短转移)</span><br><span class="line">　　　　LOOP　　　　　　CX不为零时循环.</span><br><span class="line">　　　　LOOPE/LOOPZ　　CX不为零且标志Z=1时循环.</span><br><span class="line">　　　　LOOPNE/LOOPNZ　CX不为零且标志Z=0时循环.</span><br><span class="line">　　　　JCXZ　　　　　　CX为零时转移.</span><br><span class="line">　　　　JECXZ　　　　　ECX为零时转移.</span><br><span class="line">　　4&gt;中断指令</span><br><span class="line">　　　　INT　　中断指令</span><br><span class="line">　　　　INTO　　溢出中断</span><br><span class="line">　　　　IRET　　中断返回</span><br><span class="line">　　5&gt;处理器控制指令</span><br><span class="line">　　　　HLT　　处理器暂停, 直到出现中断或复位信号才继续.</span><br><span class="line">　　　　WAIT　　当芯片引线TEST为高电平时使CPU进入等待状态.</span><br><span class="line">　　　　ESC　　转换到外处理器.</span><br><span class="line">　　　　LOCK　　封锁总线.</span><br><span class="line">　　　　NOP　　空操作.</span><br><span class="line">　　　　STC　　置进位标志位.</span><br><span class="line">　　　　CLC　　清进位标志位.</span><br><span class="line">　　　　CMC　　进位标志取反.</span><br><span class="line">　　　　STD　　置方向标志位.</span><br><span class="line">　　　　CLD　　清方向标志位.</span><br><span class="line">　　　　STI　　置中断允许位.</span><br><span class="line">　　　　CLI　　清中断允许位.</span><br><span class="line">六、伪指令</span><br><span class="line">     DW　　　定义字(2字节).</span><br><span class="line">　　　　PROC　　定义过程.</span><br><span class="line">　　　　ENDP　　过程结束.</span><br><span class="line">　　　　SEGMENT 定义段.</span><br><span class="line">　　　　ASSUME　建立段寄存器寻址.</span><br><span class="line">　　　　ENDS　　段结束.</span><br><span class="line">　　　　END　　程序结束. </span><br></pre></td></tr></table></figure><hr><h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code, ds:data, ss:stack</span><br><span class="line">data segment</span><br><span class="line">    dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">stack segment</span><br><span class="line">    dw 0,0,0,0,0,0,0,0</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:    </span><br><span class="line">    mov ax, stack</span><br><span class="line">    mov ss, ax</span><br><span class="line">    mov sp, 16</span><br><span class="line">    mov ax, data</span><br><span class="line">    mov ds, ax</span><br><span class="line">    </span><br><span class="line">    push ds: [0]</span><br><span class="line">    push ds: [2]</span><br><span class="line">    pop ds: [0]</span><br><span class="line">    pop ds: [2]</span><br><span class="line"></span><br><span class="line">    mov ax, 4c00h</span><br><span class="line">    int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/blog/2021/08/24/%E7%AE%80%E6%98%93%E6%B1%87%E7%BC%96%E5%85%A5%E9%97%A8/markdown\blog\source_posts\简易汇编入门\image-20210816094647550.png" alt="image-20210816094647550"></p><p><img src="/blog/2021/08/24/%E7%AE%80%E6%98%93%E6%B1%87%E7%BC%96%E5%85%A5%E9%97%A8/markdown\blog\source_posts\简易汇编入门\image-20210816094718749.png" alt="image-20210816094718749"></p><hr><h2 id="大小端序"><a href="#大小端序" class="headerlink" title="大小端序"></a>大小端序</h2><ul><li>为什么data在内存中是反的？</li><li>既然字节是内存最小单元，那么应该如何存储字、双字、甚至四字数据？</li><li>小端序：低地址存低字节</li><li>大端序：低地址存高字节</li></ul><h1 id="栈帧"><a href="#栈帧" class="headerlink" title="栈帧"></a>栈帧</h1><hr><h2 id="栈模型"><a href="#栈模型" class="headerlink" title="栈模型"></a>栈模型</h2><ul><li>为什么要<code>mov sp, 16</code>？</li><li>栈是一种与队列相反的特殊数据结构。</li></ul><p><img src="/blog/2021/08/24/%E7%AE%80%E6%98%93%E6%B1%87%E7%BC%96%E5%85%A5%E9%97%A8/markdown\blog\source_posts\简易汇编入门\image-20210816094109547.png" alt="image-20210816094109547"></p><ul><li>栈指针：寄存器<code>ebp</code>和<code>esp</code>分别指向指向栈底和栈顶（当前栈帧）。</li></ul><p><img src="/blog/2021/08/24/%E7%AE%80%E6%98%93%E6%B1%87%E7%BC%96%E5%85%A5%E9%97%A8/markdown\blog\source_posts\简易汇编入门\image-20210815201356541.png" alt="image-20210815201356541"></p><ul><li>因此要<code>mov sp, 16</code>，为栈开辟空间。</li></ul><hr><h2 id="栈帧-1"><a href="#栈帧-1" class="headerlink" title="栈帧"></a>栈帧</h2><ul><li>栈帧也叫过程活动记录，是编译器用来实现过程/函数调用的一种数据结构。</li><li>函数调用有什么问题，为什么需要用到栈？<ol><li>传参</li><li>返回地址</li><li>局部变量</li></ol></li><li>三种调用方式与栈帧</li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;计组入门&quot;&gt;&lt;a href=&quot;#计组入门&quot; class=&quot;headerlink&quot; title=&quot;计组入门&quot;&gt;&lt;/a&gt;计组入门&lt;/h1&gt;&lt;hr&gt;
&lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;&lt;p&gt;​    计算机执行时能够理解的只有机器语言，即用“01”表示的代码，而汇编语言，其实是将这种01表示为人类可以记住的字符和数字，它是一种低级语言，可以直接描述/控制 CPU 的运行。如果你想知道计算机如何执行代码、CPU如何工作、高级语言的本质工作、以至于学习二进制，就一定要学习汇编语言。&lt;/p&gt;</summary>
    
    
    
    <category term="Reverse" scheme="https://lightship568.github.io/blog/categories/Reverse/"/>
    
    
  </entry>
  
  <entry>
    <title>OllyDBG学习手册</title>
    <link href="https://lightship568.github.io/blog/2021/08/23/OllyDBG%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C/"/>
    <id>https://lightship568.github.io/blog/2021/08/23/OllyDBG%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C/</id>
    <published>2021-08-23T10:23:49.000Z</published>
    <updated>2023-10-29T12:18:27.819Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><ol><li><p>快捷键：</p><p><img src="/blog/2021/08/23/OllyDBG%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C/markdown\blog\source_posts\OllyDBG学习手册\image-20210704092707595.png" alt="image-20210704092707595"></p><span id="more"></span></li><li><p>在进入子程序的过程中，若想会看之前的单步跟踪的代码，可以按‘-’（减号）键；若想让光标回到当前EIP所指向的语句，可以单击【C】按钮或双击EIP寄存器</p></li><li><p>Ctrl+F7或Ctrl+F8可以自动跟进或跟过，直到用户按Esc或F12键或遇其他断点时停止。</p></li><li><p>call指令中，可以按Ctrl+F9（执行到返回），OllyDbg会停在遇到的第一个返回命令处（ret、retf或iret）。</p><p>可以在Trace中设置是否直接返回</p><p><img src="/blog/2021/08/23/OllyDBG%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C/markdown\blog\source_posts\OllyDBG学习手册\image-20210704093345586.png" alt="image-20210704093345586"></p></li><li><p>如果跟进了系统的dll（一般地址较高），如：</p><p><img src="/blog/2021/08/23/OllyDBG%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C/markdown\blog\source_posts\OllyDBG学习手册\image-20210704093655845.png" alt="image-20210704093655845"></p><p>使用Alt+F9回到应用程序领空</p></li><li><p>F9直接运行，Ctrl+F2重调，死循环可使用F12暂停</p></li></ol><h2 id="断点"><a href="#断点" class="headerlink" title="断点"></a>断点</h2><ol><li>F2下断点，Ctrl+G打开跟随表达式窗口，可以输入函数名称（如GetDlgItemTextA）跳转到相应函数的入口处；</li><li>也可以右键反汇编窗口，选择查找当前模块名称（或按Ctrl+N快捷键），获取程序的API函数，只需要输入API函数名称，在目标函数上按Enter或右键“Find references to import”，打开调用此函数的参考代码窗口，找到相应代码再按Enter，即可切换相应代码处。</li><li>如果使用CmdBar.all插件，可以直接在命令行环境中使用bp命令下断点（如“bp GetDlgItemTextA”）</li><li>F4运行到光标处（使用硬件断点原理）</li></ol><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><ol><li>查看程序运行内存：alt+M打开内存窗口，在上面一行按ctrl+B可以打开搜索框</li></ol>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;h2 id=&quot;调试&quot;&gt;&lt;a href=&quot;#调试&quot; class=&quot;headerlink&quot; title=&quot;调试&quot;&gt;&lt;/a&gt;调试&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;快捷键：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/blog/2021/08/23/OllyDBG%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C/markdown&#92;blog&#92;source_posts&#92;OllyDBG学习手册&#92;image-20210704092707595.png&quot; alt=&quot;image-20210704092707595&quot;&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;</summary>
    
    
    
    <category term="Reverse" scheme="https://lightship568.github.io/blog/categories/Reverse/"/>
    
    
  </entry>
  
  <entry>
    <title>IDA学习手册</title>
    <link href="https://lightship568.github.io/blog/2021/08/23/IDA%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C/"/>
    <id>https://lightship568.github.io/blog/2021/08/23/IDA%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C/</id>
    <published>2021-08-23T08:59:54.000Z</published>
    <updated>2023-10-29T12:06:22.474Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><ol><li>G：Jump to address，跳转到地址</li><li>shift+F12：字符串窗口</li><li>x：查找交叉引用</li><li>N：参考重命名<span id="more"></span></li><li>标记：<ul><li>菜单Jump-&gt;Mark position标记当前位置</li><li>Ctrl+M跳转到标记位置</li></ul></li><li>格式化指令数<ul><li>右键-&gt;Use starndard symbolic constant确定操作数的符号名称</li><li>如根据CreateWindow参数，确定对应符号为CW_USEDEFAULT</li></ul></li><li>p：process，创建函数</li><li>c：code，转换为代码段</li><li>u：undefine，取消定义</li><li>d：数据类型转换<ul><li>数据类型在db、dw、dd之间转换</li><li>Options-&gt;setup data types，设置更多数据类型</li></ul></li><li>a：ASCII，转换为字符串<ul><li>Options-&gt;ASCII string style设置除默认C格式外的其他字符串格式默认值</li></ul></li><li>*：数组重新排列调整</li><li>shift+F11：加载类型库窗口，可引入结构体</li><li>t：offset，执行结构体偏移</li><li>m：Enum，转换为枚举成员</li><li>Ctrl+K：打开栈窗口（双击函数栈即可）</li><li>Ctrl+F1：获取API帮助</li></ol><hr><h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><ul><li>SMC：Self Modifying Code</li><li>爆破法：跳过算法分析直接修改关键跳转指令使程序注册成功的方法</li></ul><hr><h2 id="创建结构体"><a href="#创建结构体" class="headerlink" title="创建结构体"></a>创建结构体</h2><ol><li><p>使用内置类型</p><ul><li>使用shift+F11键打开加载类型库窗口，单击右键，在弹出的快捷菜单中选择Load Type Library（或按insert键），在弹出的Available Type Libraries窗口种选择类型库</li><li>查看内置的结构体数据结构后，选择View-&gt;Open subviews-&gt;Structures菜单项，打开结构体管理窗口。按Insert键单击Add Standard Structure按钮,打开添加标准结构库窗口，查找需要的结构名，就可以正常使用这些库了</li></ul></li><li><p>自定义结构体</p><ul><li>打开结构体窗口，按Insert键新增一个结构体类型，使用d键加入数据，重复按d键则会在db、dwdd之间切换，按a键加入ascii字符（若结构体大小可变，可以将自定义数组大小设为0）</li></ul></li><li><p>单数据纠正</p><ul><li>在需要转换结构体的数据处，执行Edit-&gt;Structs-&gt;Struct var，选择对应结构体类型即可将单数据纠正</li></ul></li><li><p>结构体偏移</p><ul><li>使用T键将一个结构体中的所有成员变量一并修正</li></ul></li><li><p>导入结构体</p><ul><li>菜单项Load file -&gt; Parse C header file加载子自定义的头文件</li></ul></li></ol><hr><h2 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h2><ol><li>使用枚举替换无实际意义的数字<ul><li>View-&gt;Open subviews-&gt;Enumerations，使用inset插入新枚举类型，在其中按N键添加枚举成员</li><li>在数据处按M键即可将其转换为指定的枚举成员</li></ul></li></ol><hr><h2 id="FLIRT签名"><a href="#FLIRT签名" class="headerlink" title="FLIRT签名"></a>FLIRT签名</h2><ul><li>Fast Library Identification and Recongnition Technology    库文件快速识别与鉴定技术。</li><li>IDA通常可以识别一些编译器，但不一定都能成功，如特定版本编译器产生的（如微软记事本）程序，或程序里的编译器的资料被删除了（如用高级语言编写的病毒程序），还有一种情况是编译器不支持而导致识别失败。</li></ul><ol><li>如果IDA支持程序的编译器，但FLIRT没有自动将其识别出来，就可以强制使用器编译器特征文件。<ul><li>使用shift+F5或View-&gt;Open subviews-&gt;Signatures打开签名窗口，右键，在弹出的菜单中选择Apply new signature或按insert键打开库文件列表窗口，选中相应库（如Delphi 5 Component Library）即可激活相应签名文件。</li><li>若IDA应用新的签名文件后没有自动重新分析全部代码，可以单击菜单Options-&gt;Analysis打开分析配置选项，然后单击Reanalyse program重新分析程序按钮。</li></ul></li><li>创建FLIRT签名文件</li></ol><ul><li>使用IDA提供的FLIRT数据库生成工具FLAIR，方便用户自行制作识别库签名文件</li></ul><hr><h2 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h2><p>IDA集成的脚本引擎支持两种语言，分别是IDC（类C的语言脚本控制器）和Python（IDA从6.8开始直接支持），IDC使用方法略</p><ul><li>Python脚本使用</li></ul><hr><h2 id="调试器（暂略）"><a href="#调试器（暂略）" class="headerlink" title="调试器（暂略）"></a>调试器（暂略）</h2><hr><h2 id="其他功能"><a href="#其他功能" class="headerlink" title="其他功能"></a>其他功能</h2><ol><li><p>图形化模式：使用空格键切换，提供总览窗口</p></li><li><p>修改可执行文件</p><ul><li>patch提供十六进制形式修改数据</li><li>Hex View可以直接修改字节（右键快捷菜单中选择Edit）</li><li>使用汇编语句修改代码段</li><li>Apply patches to input file，将改动更新到二进制文件中</li><li>推荐使用KeyPatch插件</li></ul></li><li><p>加载符号文件</p><ul><li>Load file-&gt;PDB file，加载DBG和PDB文件</li><li>此功能对系统软件非常强大，只要机器联网IDA就会自动到微软网站寻找适合当前版本的PDB或DBG文件</li></ul></li><li><p>API帮助关联</p><ul><li>将idagui.cfg中的HELPFILE指向Windows API帮助文件。这样只需选中某API并按Ctrl+F1就可以获得该API的帮助信息</li></ul></li><li><p>输出文件</p><ul><li>反汇编代码输出功能通过菜单File-&gt;Produce file调用，可以以MAP、ASM、LST、EXE、DIF等格式输出文件</li></ul><ol><li>MAP：是一个文本文件，其中记录了程序调用的函数等符号信息</li><li>ASM：仅输出汇编代码部分，每行代码之前都没有地址。若只想输出一段代码，选择要保存的代码，然后执行File-&gt;Create ASM file命令即可</li><li>Dump database to IDC file命令：将当前IDA的数据变化记录到IDC文件中，供恢复当前数据时使用。由于每个版本的IDA都有自己的数据格式且不互相兼容，可以使用该命令将低版本中的工作记录转换到高版本中。可以在高版本中重新载入和分析原始文件，完成后按F2键打开该IDC 脚本并执行。执行结束，注释、重命名等记录都将导入新版本的IDA中</li></ol></li></ol>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;h2 id=&quot;快捷键&quot;&gt;&lt;a href=&quot;#快捷键&quot; class=&quot;headerlink&quot; title=&quot;快捷键&quot;&gt;&lt;/a&gt;快捷键&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;G：Jump to address，跳转到地址&lt;/li&gt;
&lt;li&gt;shift+F12：字符串窗口&lt;/li&gt;
&lt;li&gt;x：查找交叉引用&lt;/li&gt;
&lt;li&gt;N：参考重命名&lt;/li&gt;&lt;/ol&gt;</summary>
    
    
    
    <category term="Reverse" scheme="https://lightship568.github.io/blog/categories/Reverse/"/>
    
    
  </entry>
  
  <entry>
    <title>B站404漫画爬虫</title>
    <link href="https://lightship568.github.io/blog/2021/08/22/B%E7%AB%99404%E6%BC%AB%E7%94%BB%E7%88%AC%E8%99%AB/"/>
    <id>https://lightship568.github.io/blog/2021/08/22/B%E7%AB%99404%E6%BC%AB%E7%94%BB%E7%88%AC%E8%99%AB/</id>
    <published>2021-08-22T12:45:54.000Z</published>
    <updated>2023-10-29T12:17:09.235Z</updated>
    
    <content type="html"><![CDATA[<hr><p><code>本篇更新于2020.4</code>    </p><p>　　众所周知B站<code>url</code>访问失效的页面会有很多漫画，在不知道数量的情况下还是随机显示，因此打算使用爬虫爬到本地来全面欣赏。抓包分析发现漫画是<code>js</code>动态获取的，加载完成后加入<code>.error-manga</code>标签下。</p><span id="more"></span><hr><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>　　按钮<code>.change-img-btn</code>通过<code>herf=#up</code>实现无刷新加载新图片，而这个功能实际上是<code>js</code>实现的，通过<code>DevTools</code>选择<code>Event Listeners</code>，找到<code>click</code>功能下的该按钮挂载的<code>js</code>文件：<code>error.js</code>，是个匿名函数，代码如下。</p><h3 id="取漫画url"><a href="#取漫画url" class="headerlink" title="取漫画url"></a>取漫画url</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = []</span><br><span class="line">, o = [<span class="string">&quot;http://activity.hdslb.com/zzjs/cartoon/errorPage-manga-1.png&quot;</span>, <span class="string">&quot;http://activity.hdslb.com/zzjs/cartoon/errorPage-manga-2.png&quot;</span>, <span class="string">&quot;http://activity.hdslb.com/zzjs/cartoon/errorPage-manga-3.png&quot;</span>, <span class="string">&quot;http://activity.hdslb.com/zzjs/cartoon/errorPage-manga-4.png&quot;</span>, <span class="string">&quot;http://activity.hdslb.com/zzjs/cartoon/errorPage-manga-5.png&quot;</span>, <span class="string">&quot;http://activity.hdslb.com/zzjs/cartoon/errorPage-manga-6.png&quot;</span>, <span class="string">&quot;http://activity.hdslb.com/zzjs/cartoon/errorPage-manga-7.png&quot;</span>];</span><br><span class="line"><span class="keyword">var</span> t = <span class="literal">false</span>;</span><br><span class="line">r.ajax(&#123;</span><br><span class="line"><span class="attr">url</span>: <span class="string">&quot;//www.bilibili.com/activity/web/view/data/31&quot;</span>,</span><br><span class="line"><span class="attr">type</span>: <span class="string">&quot;get&quot;</span>,</span><br><span class="line"><span class="attr">dataType</span>: <span class="string">&quot;json&quot;</span>,</span><br><span class="line"><span class="attr">async</span>: <span class="literal">false</span>,</span><br><span class="line"><span class="attr">timeout</span>: <span class="number">3e3</span>,</span><br><span class="line"><span class="attr">success</span>: <span class="function"><span class="keyword">function</span>(<span class="params">r</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">var</span> o = r.data &amp;&amp; r.data.list;</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">var</span> e <span class="keyword">in</span> o) &#123;</span><br><span class="line">     a.push((o[e].data &amp;&amp; o[e].data.img).replace(<span class="regexp">/^http:/</span>, <span class="string">&quot;&quot;</span>))</span><br><span class="line"> &#125;</span><br><span class="line"> t = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="随机选取"><a href="#随机选取" class="headerlink" title="随机选取"></a>随机选取</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> e = <span class="function"><span class="keyword">function</span>(<span class="params">r</span>) </span>&#123; </span><br><span class="line">     <span class="keyword">var</span> i = t ? a : o; </span><br><span class="line">     d = <span class="built_in">parseInt</span>(<span class="built_in">Math</span>.random() * i.length);</span><br><span class="line">     <span class="keyword">var</span> n = i[d];</span><br><span class="line">     <span class="keyword">if</span> (n != r) &#123;</span><br><span class="line">         <span class="keyword">return</span> n</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> e(r)</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line">g = e ( );</span><br></pre></td></tr></table></figure><h3 id="前端展示"><a href="#前端展示" class="headerlink" title="前端展示"></a>前端展示</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> l = c.find(<span class="string">&quot;.error-manga&quot;</span>);</span><br><span class="line">l.html(<span class="string">&quot;&lt;img src=&quot;</span> + g + <span class="string">&#x27;&gt;&lt;a class=&quot;change-img-btn&quot;&gt;换一张&lt;a/&gt;&#x27;</span>);</span><br></pre></td></tr></table></figure><p>　　注：<code>o[]</code>数组的作用是在<code>ajax</code>取漫画<code>url</code>失败时，保证前端也可以显示几张漫画。</p><hr><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>​        找到请求的列表包：</p><p><img src="/blog/2021/08/22/B%E7%AB%99404%E6%BC%AB%E7%94%BB%E7%88%AC%E8%99%AB/markdown\blog\source_posts\B站404漫画爬虫\image-20210127115343041.png" alt="image-20210127115343041"></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Content-Length: <span class="number">14527</span></span><br><span class="line"></span><br><span class="line">&#123;<span class="attr">&quot;code&quot;</span>:<span class="number">0</span>,<span class="attr">&quot;data&quot;</span>:&#123;<span class="attr">&quot;list&quot;</span>:[</span><br><span class="line"></span><br><span class="line">&#123;<span class="attr">&quot;id&quot;</span>:<span class="string">&quot;1994&quot;</span>,<span class="attr">&quot;vid&quot;</span>:<span class="string">&quot;31&quot;</span>,<span class="attr">&quot;name&quot;</span>:<span class="string">&quot;79&quot;</span>,<span class="attr">&quot;data&quot;</span>:&#123;<span class="attr">&quot;img&quot;</span>:<span class="string">&quot;\/\/i0.hdslb.com\/bfs\/activity-plat\/cover\/20171215\/o6y3r7or6z.png&quot;</span>&#125;,<span class="attr">&quot;stime&quot;</span>:<span class="string">&quot;2017-12-15 11:21:12&quot;</span>,<span class="attr">&quot;etime&quot;</span>:<span class="string">&quot;2020-09-05 11:21:12&quot;</span>&#125;,&#123;<span class="attr">&quot;id&quot;</span>:<span class="string">&quot;1992&quot;</span>,<span class="attr">&quot;vid&quot;</span>:<span class="string">&quot;31&quot;</span>,<span class="attr">&quot;name&quot;</span>:<span class="string">&quot;77&quot;</span>,<span class="attr">&quot;data&quot;</span>:&#123;<span class="attr">&quot;img&quot;</span>:<span class="string">&quot;\/\/i0.hdslb.com\/bfs\/activity-plat\/cover\/20171215\/2978n4wwpj.png&quot;</span>&#125;,<span class="attr">&quot;stime&quot;</span>:<span class="string">&quot;2017-12-15 11:20:51&quot;</span>,<span class="attr">&quot;etime&quot;</span>:<span class="string">&quot;2020-09-08 11:20:51&quot;</span>&#125;,&#123;<span class="attr">&quot;id&quot;</span>:<span class="string">&quot;1990&quot;</span>,<span class="attr">&quot;vid&quot;</span>:<span class="string">&quot;31&quot;</span>,<span class="attr">&quot;name&quot;</span>:<span class="string">&quot;76&quot;</span>,<span class="attr">&quot;data&quot;</span>:&#123;<span class="attr">&quot;img&quot;</span>:<span class="string">&quot;\/\/i0.hdslb.com\/bfs\/activity-plat\/cover\/20171215\/697mr4w97k.png&quot;</span>&#125;,<span class="attr">&quot;stime&quot;</span>:<span class="string">&quot;2017-12-15 11:20:27&quot;</span>,<span class="attr">&quot;etime&quot;</span>:<span class="string">&quot;2019-08-06 11:20:27&quot;</span>&#125;,&#123;<span class="attr">&quot;id&quot;</span>:<span class="string">&quot;1988&quot;</span>,<span class="attr">&quot;vid&quot;</span>:<span class="string">&quot;31&quot;</span>,<span class="attr">&quot;name&quot;</span>:<span class="string">&quot;78&quot;</span>,<span class="attr">&quot;data&quot;</span>:&#123;<span class="attr">&quot;img&quot;</span>:<span class="string">&quot;\/\/i0.hdslb.com\/bfs\/activity-plat\/cover\/20171215\/1297m40w7j.png&quot;</span>&#125;,<span class="attr">&quot;stime&quot;</span>:<span class="string">&quot;2017-12-15 11:19:51&quot;</span>,<span class="attr">&quot;etime&quot;</span>:<span class="string">&quot;2019-10-06 11:19:51&quot;</span>&#125;,</span><br><span class="line"></span><br><span class="line">........</span><br><span class="line"></span><br><span class="line">&#123;<span class="attr">&quot;id&quot;</span>:<span class="string">&quot;481&quot;</span>,<span class="attr">&quot;vid&quot;</span>:<span class="string">&quot;31&quot;</span>,<span class="attr">&quot;name&quot;</span>:<span class="string">&quot;1&quot;</span>,<span class="attr">&quot;data&quot;</span>:&#123;<span class="attr">&quot;img&quot;</span>:<span class="string">&quot;\/\/i0.hdslb.com\/bfs\/activity-plat\/cover\/20170511\/w44xw6r98w.png&quot;</span>&#125;,<span class="attr">&quot;stime&quot;</span>:<span class="string">&quot;2017-05-11 00:00:00&quot;</span>,<span class="attr">&quot;etime&quot;</span>:<span class="string">&quot;2018-12-01 00:00:00&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">]&#125;&#125;</span><br></pre></td></tr></table></figure><p>　　因此本次请求是79张漫画，也是无刷新使用《下一张》按钮的上线张数。当然也可以<code>js</code>单步调试，直接得到 i 数组：</p><p><img src="/blog/2021/08/22/B%E7%AB%99404%E6%BC%AB%E7%94%BB%E7%88%AC%E8%99%AB/markdown\blog\source_posts\B站404漫画爬虫\image-20210127121654155.png" alt="image-20210127121654155"></p><p>　　值得注意的是不关闭浏览器刷新不会返回新的数据，而是返回<code>ok</code>，因此关闭清除缓存进行二次对比：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Content-Length: <span class="number">14527</span></span><br><span class="line"></span><br><span class="line">&#123;<span class="attr">&quot;code&quot;</span>:<span class="number">0</span>,<span class="attr">&quot;data&quot;</span>:&#123;<span class="attr">&quot;list&quot;</span>:[</span><br><span class="line"></span><br><span class="line">&#123;<span class="attr">&quot;id&quot;</span>:<span class="string">&quot;1994&quot;</span>,<span class="attr">&quot;vid&quot;</span>:<span class="string">&quot;31&quot;</span>,<span class="attr">&quot;name&quot;</span>:<span class="string">&quot;79&quot;</span>,<span class="attr">&quot;data&quot;</span>:&#123;<span class="attr">&quot;img&quot;</span>:<span class="string">&quot;\/\/i0.hdslb.com\/bfs\/activity-plat\/cover\/20171215\/o6y3r7or6z.png&quot;</span>&#125;,<span class="attr">&quot;stime&quot;</span>:<span class="string">&quot;2017-12-15 11:21:12&quot;</span>,<span class="attr">&quot;etime&quot;</span>:<span class="string">&quot;2020-09-05 11:21:12&quot;</span>&#125;,&#123;<span class="attr">&quot;id&quot;</span>:<span class="string">&quot;1992&quot;</span>,<span class="attr">&quot;vid&quot;</span>:<span class="string">&quot;31&quot;</span>,<span class="attr">&quot;name&quot;</span>:<span class="string">&quot;77&quot;</span>,<span class="attr">&quot;data&quot;</span>:&#123;<span class="attr">&quot;img&quot;</span>:<span class="string">&quot;\/\/i0.hdslb.com\/bfs\/activity-plat\/cover\/20171215\/2978n4wwpj.png&quot;</span>&#125;,<span class="attr">&quot;stime&quot;</span>:<span class="string">&quot;2017-12-15 11:20:51&quot;</span>,<span class="attr">&quot;etime&quot;</span>:<span class="string">&quot;2020-09-08 11:20:51&quot;</span>&#125;,&#123;<span class="attr">&quot;id&quot;</span>:<span class="string">&quot;1990&quot;</span>,<span class="attr">&quot;vid&quot;</span>:<span class="string">&quot;31&quot;</span>,<span class="attr">&quot;name&quot;</span>:<span class="string">&quot;76&quot;</span>,<span class="attr">&quot;data&quot;</span>:&#123;<span class="attr">&quot;img&quot;</span>:<span class="string">&quot;\/\/i0.hdslb.com\/bfs\/activity-plat\/cover\/20171215\/697mr4w97k.png&quot;</span>&#125;,<span class="attr">&quot;stime&quot;</span>:<span class="string">&quot;2017-12-15 11:20:27&quot;</span>,<span class="attr">&quot;etime&quot;</span>:<span class="string">&quot;2019-08-06 11:20:27&quot;</span>&#125;,</span><br><span class="line"></span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>​        发现列表完全一致，再次检查<code>js</code>发现有如下代码：</p><p><img src="/blog/2021/08/22/B%E7%AB%99404%E6%BC%AB%E7%94%BB%E7%88%AC%E8%99%AB/markdown\blog\source_posts\B站404漫画爬虫\image-20210127130739261.png" alt="image-20210127130739261"></p><p>​        a即列表数组，可获取的漫画只有79张……..</p><hr><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>　　好了，开始写爬虫</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line">headers=&#123;</span><br><span class="line">   <span class="string">&#x27;Connection&#x27;</span>: <span class="string">&#x27;keep-alive&#x27;</span>,</span><br><span class="line">   <span class="string">&#x27;sec-ch-ua-mobile&#x27;</span>: <span class="string">&#x27;?0&#x27;</span>,</span><br><span class="line">   <span class="string">&#x27;Upgrade-Insecure-Requests&#x27;</span>: <span class="string">&#x27;1&#x27;</span>,</span><br><span class="line">   <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.141 Safari/537.36&#x27;</span>,</span><br><span class="line">   <span class="string">&#x27;Accept&#x27;</span>: <span class="string">&#x27;text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9&#x27;</span>,</span><br><span class="line">   <span class="string">&#x27;Sec-Fetch-Site&#x27;</span>: <span class="string">&#x27;none&#x27;</span>,</span><br><span class="line">   <span class="string">&#x27;Sec-Fetch-Mode&#x27;</span>: <span class="string">&#x27;navigate&#x27;</span>,</span><br><span class="line">   <span class="string">&#x27;Sec-Fetch-User&#x27;</span>: <span class="string">&#x27;?1&#x27;</span>,</span><br><span class="line">   <span class="string">&#x27;Sec-Fetch-Dest&#x27;</span>: <span class="string">&#x27;document&#x27;</span>,</span><br><span class="line">   <span class="string">&#x27;Accept-Encoding&#x27;</span>: <span class="string">&#x27;gzip, deflate, br&#x27;</span>,</span><br><span class="line">   <span class="string">&#x27;Accept-Language&#x27;</span>: <span class="string">&#x27;zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7,zh-TW;q=0.6&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">url = <span class="string">&#x27;https://www.bilibili.com/activity/web/view/data/31&#x27;</span></span><br><span class="line">response = requests.get(url, headers=headers, timeout=<span class="number">10</span>)</span><br><span class="line">res = json.loads(response.text) <span class="comment">#json字符串解析成py list</span></span><br><span class="line"><span class="keyword">for</span> index <span class="keyword">in</span> res[<span class="string">&#x27;data&#x27;</span>][<span class="string">&#x27;list&#x27;</span>]:</span><br><span class="line">   <span class="built_in">str</span> = index[<span class="string">&#x27;data&#x27;</span>][<span class="string">&#x27;img&#x27;</span>]</span><br><span class="line">   <span class="built_in">str</span> = <span class="built_in">str</span>.replace(<span class="string">&#x27;\\&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">   <span class="built_in">str</span> = <span class="built_in">str</span>.replace(<span class="string">&#x27;//&#x27;</span>, <span class="string">&#x27;https://&#x27;</span>)</span><br><span class="line">   img = requests.get(<span class="built_in">str</span>, headers=headers, timeout=<span class="number">10</span>).content</span><br><span class="line">   <span class="comment">#需要创建img目录</span></span><br><span class="line">   <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;./img/&#x27;</span> + index[<span class="string">&#x27;name&#x27;</span>]+<span class="string">&#x27;.jpg&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>)<span class="keyword">as</span> fp:</span><br><span class="line">       fp.write(img)</span><br><span class="line">       <span class="built_in">print</span>(index[<span class="string">&#x27;name&#x27;</span>]+<span class="string">&#x27; saved&#x27;</span>)</span><br><span class="line">   <span class="comment">#几秒暂停防封</span></span><br><span class="line">   time.sleep(random.randint(<span class="number">3</span>,<span class="number">7</span>))</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">main()</span><br></pre></td></tr></table></figure><h2 id="FIN"><a href="#FIN" class="headerlink" title="FIN"></a>FIN</h2>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;p&gt;&lt;code&gt;本篇更新于2020.4&lt;/code&gt;    &lt;/p&gt;
&lt;p&gt;　　众所周知B站&lt;code&gt;url&lt;/code&gt;访问失效的页面会有很多漫画，在不知道数量的情况下还是随机显示，因此打算使用爬虫爬到本地来全面欣赏。抓包分析发现漫画是&lt;code&gt;js&lt;/code&gt;动态获取的，加载完成后加入&lt;code&gt;.error-manga&lt;/code&gt;标签下。&lt;/p&gt;</summary>
    
    
    
    <category term="Fun" scheme="https://lightship568.github.io/blog/categories/Fun/"/>
    
    
  </entry>
  
</feed>
