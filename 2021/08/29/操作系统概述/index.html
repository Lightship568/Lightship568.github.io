<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>操作系统概述 | Lightship</title><meta name="author" content="Lightship"><meta name="copyright" content="Lightship"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="建设中，未完待续 操作系统引论 1.发展过程 无操作系统：人工、脱机输入&#x2F;输出 单道批处理系统 多道批处理系统 分时系统">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统概述">
<meta property="og:url" content="https://lightship568.github.io/2021/08/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/index.html">
<meta property="og:site_name" content="Lightship">
<meta property="og:description" content="建设中，未完待续 操作系统引论 1.发展过程 无操作系统：人工、脱机输入&#x2F;输出 单道批处理系统 多道批处理系统 分时系统">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png">
<meta property="article:published_time" content="2021-08-29T07:16:36.000Z">
<meta property="article:modified_time" content="2021-09-10T11:37:48.000Z">
<meta property="article:author" content="Lightship">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://lightship568.github.io/2021/08/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Error',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '操作系统概述',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-09-10 19:37:48'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="Lightship" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">8</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">3</div></a></div><hr class="custom-hr"/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="Lightship"><span class="site-name">Lightship</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">操作系统概述</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2021-08-29T07:16:36.000Z" title="Created 2021-08-29 15:16:36">2021-08-29</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2021-09-10T11:37:48.000Z" title="Updated 2021-09-10 19:37:48">2021-09-10</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Basic/">Basic</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="操作系统概述"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><hr>
<p><code>建设中，未完待续</code></p>
<h2 id="操作系统引论"><a href="#操作系统引论" class="headerlink" title="操作系统引论"></a>操作系统引论</h2><hr>
<h3 id="1-发展过程"><a href="#1-发展过程" class="headerlink" title="1.发展过程"></a>1.发展过程</h3><ol>
<li><strong>无操作系统</strong>：人工、脱机输入/输出</li>
<li><strong>单道批处理系统</strong></li>
<li><strong>多道批处理系统</strong></li>
<li><strong>分时系统</strong><span id="more"></span><ul>
<li>多路性</li>
<li>独立性</li>
<li>及时性</li>
<li>交互性</li>
</ul>
</li>
<li><strong>实时系统</strong><ul>
<li>多路性</li>
<li>独立性</li>
<li>及时性</li>
<li>交互性</li>
<li>可靠性</li>
</ul>
</li>
<li><strong>微机操作系统</strong></li>
</ol>
<h3 id="2-基本特征"><a href="#2-基本特征" class="headerlink" title="2.基本特征"></a>2.基本特征</h3><ul>
<li><strong>并发性</strong></li>
<li><strong>共享性</strong></li>
<li><strong>虚拟性</strong></li>
<li><strong>异步性</strong></li>
</ul>
<h3 id="3-功能"><a href="#3-功能" class="headerlink" title="3.功能"></a>3.功能</h3><ol>
<li><strong>处理机管理</strong>：在传统操作系统中， 处理机的分配和运行都是以进程为基本单位，因此通常将处理管理归结为对进程的管理。<ul>
<li>进程控制</li>
<li>进程同步</li>
<li>进程通信</li>
<li>进程调度</li>
</ul>
</li>
<li><strong>储存器管理</strong><ul>
<li>内存分配</li>
<li>内存保护</li>
<li>地址映射</li>
<li>内存扩充</li>
</ul>
</li>
<li><strong>设备管理</strong><ul>
<li>缓冲管理</li>
<li>设备分配</li>
<li>设备处理</li>
</ul>
</li>
<li><strong>文件管理</strong><ul>
<li>文件储存空间的管理</li>
<li>目录管理</li>
<li>文件的读/写管理和保护</li>
</ul>
</li>
<li><strong>友好的用户接口</strong><ul>
<li>用户接口</li>
<li>程序接口</li>
</ul>
</li>
<li><strong>现代操作系统的新功能</strong><ul>
<li>系统安全</li>
<li>网络的功能和服务</li>
<li>支持多媒体</li>
</ul>
</li>
</ol>
<h3 id="4-结构设计"><a href="#4-结构设计" class="headerlink" title="4.结构设计"></a>4.结构设计</h3><ol>
<li>无结构OS</li>
<li>模块化结构OS</li>
<li>分层式结构OS</li>
<li>微内核机构OS</li>
</ol>
<h2 id="进程的描述与控制"><a href="#进程的描述与控制" class="headerlink" title="进程的描述与控制"></a>进程的描述与控制</h2><hr>
<h3 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1.基本概念"></a>1.基本概念</h3><ol>
<li><p><strong>前趋图</strong></p>
</li>
<li><p><strong>程序的顺序执行</strong></p>
<ul>
<li>顺序性</li>
<li>封闭性</li>
<li>可再现性</li>
</ul>
</li>
<li><p><strong>程序的并发执行</strong></p>
<ul>
<li>间断性</li>
<li>失去封闭性</li>
<li>不可再现性</li>
</ul>
</li>
<li><p><strong>进程的定义</strong></p>
<p>至今进程没有一个统一的定义，典型进程定义有如下几种：</p>
<ul>
<li>进程是程序的一次执行</li>
<li>进程是一个程序机器数据在处理机上顺序执行时所发生的活动</li>
<li>进程是具有独立功能的程序在一个数据集合上运行的过程，他是系统进行资源分配和调度的一个独立单位</li>
</ul>
<p>​    引入进程实体概念后，我们可以把传统OS中的进程定义为：“<strong>进程是进程实体的的运行过程，是系统进行资源分配和调度的一个独立单位</strong>”。</p>
</li>
<li><p><strong>进程的特征</strong></p>
<ul>
<li>动态性</li>
<li>并发性</li>
<li>独立性</li>
<li>异步性</li>
</ul>
</li>
<li><p><strong>进程状态</strong></p>
<ul>
<li>就绪</li>
<li>执行</li>
<li>阻塞</li>
</ul>
<p>​    不少系统中，进程只有上述三种基本状态，但在另一些系统中，又增加了一些新的状态，最重要的是挂起状态：常用于进程对换中，挂起的进程可以腾出内存空间给就绪进程使用；也可以用于调节系统负荷、方便用户考察自己的运行进程或父进程考察子进程、方便操作系统检查运行中的资源使用情况或进行记账等。</p>
</li>
<li><p><strong>进程控制块</strong></p>
<p>​    PCB（Process Control Block）是进程存在的唯一标志。由于PCB要被系统频繁访问，因此PCB中的信息必须全部或者部分长常驻内存。PCB通常包含信息：</p>
<ul>
<li>进程标识符</li>
<li>处理机状态</li>
<li>进程调度信息</li>
<li>进程控制信息</li>
</ul>
</li>
</ol>
<h3 id="2-进程控制"><a href="#2-进程控制" class="headerlink" title="2.进程控制"></a>2.进程控制</h3><ol>
<li><p>操作系统内核</p>
<p>​    现代操作系统一般将OS划分为若干层次，再将OS的不同功能，分别设置在不同的层次中。通常将处理机的执行状态分为系统态和用户态两种。</p>
</li>
<li><p>进程的创建：使用原语</p>
</li>
<li><p>进程的终止：使用原语，实质是回收PCB</p>
</li>
<li><p>进程的阻塞和唤醒</p>
</li>
<li><p>进程的挂起与激活</p>
</li>
</ol>
<h3 id="3-进程同步"><a href="#3-进程同步" class="headerlink" title="3.进程同步"></a>3.进程同步</h3><ol>
<li><p><strong>基本概念</strong></p>
<p>（1）<strong>制约关系</strong></p>
<ul>
<li>间接相互制约：互斥</li>
<li>直接相互制约：同步</li>
</ul>
<p>（2）<strong>临界资源和临界区</strong></p>
<ul>
<li>访问临界资源的那段代码称为临界区</li>
<li>进入区与退出区</li>
</ul>
<p>（3）<strong>同步机制遵循的规则</strong></p>
<ul>
<li>空闲让进</li>
<li>忙则等待</li>
<li>有限等待</li>
<li>让权等待</li>
</ul>
</li>
<li><p><strong>信号量机制</strong></p>
<ul>
<li>整型信号量</li>
<li>记录型信号量</li>
</ul>
</li>
</ol>
<h3 id="4-经典进程同步问题"><a href="#4-经典进程同步问题" class="headerlink" title="4.经典进程同步问题"></a>4.经典进程同步问题</h3><ol>
<li>生产者–消费者问题</li>
<li>哲学家进餐问题</li>
<li>读者–写者问题</li>
</ol>
<h3 id="5-管程机制"><a href="#5-管程机制" class="headerlink" title="5.管程机制"></a>5.管程机制</h3><ol>
<li><p><strong>定义与特点</strong></p>
<ul>
<li>管城内的局部变量只能被局部于管程内的过程所访问，反之亦然，即局部于管程内的过程只能访问管程内的变量和形式参数</li>
<li>任何进程只能通过调用管程提供的过程入口进入管程</li>
<li>任一时刻，最多只能有一个进程在管程中执行</li>
</ul>
<p>保证进程互斥的进入管程是由编译器负责的，也就是说，管程是一种编程语言的构件，他的实现需要得到编译器的支持。</p>
</li>
<li><p><strong>条件变量</strong></p>
</li>
<li><p><strong>利用管程解决生产者–消费者问题</strong></p>
</li>
</ol>
<h3 id="6-进程通信"><a href="#6-进程通信" class="headerlink" title="6.进程通信"></a>6.进程通信</h3><ol>
<li><strong>进程通信类型</strong><ul>
<li>共享储存器系统</li>
<li>通道通信</li>
<li>消息传递系统</li>
<li>客户机–服务器系统<ul>
<li>套接字</li>
<li>远程过程调用和远程方法调用</li>
</ul>
</li>
</ul>
</li>
<li><strong>消息缓冲队列通信机制</strong></li>
</ol>
<h3 id="7-线程"><a href="#7-线程" class="headerlink" title="7.线程"></a>7.线程</h3><ol>
<li>概念</li>
<li>线程的控制</li>
<li>内核支持线程和用户级线程<ul>
<li>用户级线程</li>
<li>内核支持线程</li>
<li>组合方式</li>
</ul>
</li>
</ol>
<h2 id="处理机调度与死锁"><a href="#处理机调度与死锁" class="headerlink" title="处理机调度与死锁"></a>处理机调度与死锁</h2><hr>
<h3 id="1-处理机调度调度层次"><a href="#1-处理机调度调度层次" class="headerlink" title="1.处理机调度调度层次"></a>1.处理机调度调度层次</h3><ul>
<li>高级调度：作业调度或长程调度，将作业调入内存，分配资源并创建进程。</li>
<li>低级调度：进程调度或短程调度，决定哪个进程先获得处理机。</li>
<li>中级调度：内存调度或忠诚调度，实现内存换入换出。</li>
</ul>
<h3 id="2-调度算法"><a href="#2-调度算法" class="headerlink" title="2.调度算法"></a>2.调度算法</h3><ol>
<li>先来先服务（FCFS）</li>
<li>短作业优先（SJF）</li>
<li>优先级调度算法（PSA）<ul>
<li>静态优先权</li>
<li>动态优先权</li>
</ul>
</li>
<li>高相应比优先（HRRN）：相应比 = 响应时间 / 要求服务时间 = （等待时间+要求服务时间）/ 要求服务时间</li>
<li>时间片轮转法（RR）</li>
<li>多级队列调度</li>
<li>多级反馈队列调度（FB）</li>
</ol>
<h3 id="3-实时调度"><a href="#3-实时调度" class="headerlink" title="3.实时调度"></a>3.实时调度</h3><ol>
<li> 基本条件：截止时间。</li>
<li> 方式与算法的选择：根据实际情况要求而定。</li>
<li>常见实时调度算法<ul>
<li>最早截止时间优先（EDF）</li>
<li>最低松弛度优先（LLF）</li>
</ul>
</li>
<li> 优先级倒置：防止高优先级进程或线程被低优先级进程或线程延迟或阻塞的现象。</li>
</ol>
<h3 id="4-死锁"><a href="#4-死锁" class="headerlink" title="4.死锁"></a>4.死锁</h3><ol>
<li>原因<ul>
<li>竞争资源</li>
<li>进程推进顺序非法</li>
</ul>
</li>
<li>条件<ul>
<li>互斥条件</li>
<li>请求与保持条件</li>
<li>不剥夺条件</li>
<li>环路等待条件</li>
</ul>
</li>
</ol>
<h3 id="5-处理死锁基本方法"><a href="#5-处理死锁基本方法" class="headerlink" title="5.处理死锁基本方法"></a>5.处理死锁基本方法</h3><ol>
<li><p>预防死锁</p>
<ul>
<li>摒弃请求与保持：规定所有进程必须一次性申请其在运行过程中所需要的全部资源。</li>
<li>摒弃不剥夺：提出新资源请求得不到立即满足的进程立即释放已经获得的所有资源（复杂、代价大、反复申请）。</li>
<li>摒弃环路等待：所有进程严格按照资源号递增顺序申请资源（限制新设备类型增加，进程使用资源顺序与规定不符则造成浪费）</li>
</ul>
</li>
<li><p>避免死锁</p>
<ul>
<li>银行家算法</li>
<li>安全性算法</li>
</ul>
</li>
<li><p>死锁的检测与解除</p>
<ul>
<li><p>使用资源分配图简化来检测是否为死锁状态</p>
</li>
<li><p>死锁的解除</p>
<ul>
<li>剥夺资源</li>
<li>撤销进程</li>
</ul>
<p>处理死锁的每一种方法都需要付出一定的代价，并可能对用户作一些不便的限制，因此还要对死锁视而不见的鸵鸟算法，以求在效率和正确性之间进行折中处理。</p>
</li>
</ul>
</li>
</ol>
<h2 id="储器管理"><a href="#储器管理" class="headerlink" title="储器管理"></a>储器管理</h2><hr>
<h3 id="1-装入"><a href="#1-装入" class="headerlink" title="1.装入"></a>1.装入</h3><ol>
<li> <strong>绝对装入</strong>（编译时确定物理地址）</li>
<li> <strong>可重定位装入&amp;静态重定位</strong>（装入时确定物理地址）</li>
<li> <strong>动态运行时装入</strong>（运行时查找物理地址）</li>
</ol>
<h3 id="2-链接"><a href="#2-链接" class="headerlink" title="2.链接"></a>2.链接</h3><ol>
<li><strong>静态链接</strong>（编译时链接所有模块）</li>
<li><strong>装入时动态链接</strong>（装入时链接所有模块）</li>
<li><strong>运行时动态链接</strong>（运行时链接被调用的模块）</li>
</ol>
<h3 id="3-连续分配方式"><a href="#3-连续分配方式" class="headerlink" title="3.连续分配方式"></a>3.连续分配方式</h3><ol>
<li><p><strong>单一连续分配</strong></p>
</li>
<li><p><strong>固定分区分配</strong></p>
</li>
<li><p><strong>动态分区分配</strong></p>
<ul>
<li>首次适应算法：保留高地址较大内存空间，易产生小空闲分区增加系统查找开销。</li>
<li>循环首次适应算法：形成查找链表，继续上次查找，易缺少大空闲分区。</li>
<li>最佳适应算法：分区按大小递增排列，分配最适合，但产生的碎片最小，难以利用。</li>
<li>最坏适应算法：分区按大小递减排列，切分最大空闲分区，易缺少大空间分区。</li>
</ul>
<p>为了减少小空闲分区“碎片”，可以在分配时计算分配后剩余空闲空间，若剩余部分低于阈值则不予分配，可减少碎片产生。</p>
<p>作业运行完毕后要进行内存回收，系统检查是否有空闲分区与回收区相邻，并将之一起合并为一个大的空闲分区，并根据算法将其起始地址或分区大小插入空闲分区表或空闲分区链。</p>
</li>
<li><p><strong>伙伴系统</strong>：是固定与动态的折中方案（固定分区限制作业数，并产生内部碎片，动态分区算法复杂，回收需要合并，系统开销大），是将内存空闲分区不断一分为二，如果程序的内存使用刚好使分区不可再分，就将其分配配给程序。回收时只需每次寻找相应伙伴是否空闲即可合并，因此分配需要多次计算，一次回收也可能要进行多次合并。</p>
</li>
<li><p><strong>可重定位分区分配</strong>：在动态分区的基础上增加紧凑功能，即找不到足够大的空闲分区、而空闲分区总大小却能满足用户的要求时，对内存空间进行紧凑，要求作业在内存中移动位置，因此也需要的动态重定位技术的支持。</p>
</li>
<li><p><strong>分区的保护</strong></p>
<ul>
<li>界限寄存器：一对上下限寄存器，也可以是一对基址限长寄存器，地址访问是硬件自动比较，若发生地址越界，产生越界中断</li>
<li>保护键：为每一个分区分配一个单独的保护键，并且为每个进程分配一个相应的保护键，每当进行内存访问时，程序的键（钥匙）是否匹配分区的键（锁），若不匹配则发生保护性中断。</li>
</ul>
</li>
<li><p><strong>对换</strong>：将内存中暂时不能运行的进程或暂时不用的程序或数据，调用到外存上，以便腾出足够的内存空间，再将具备运行条件的进程或进程所需要的程序和数据调入内存。</p>
<ul>
<li>以进程为单位的对换，称为整体兑换或进程对换。这种对换广泛应用于分时系统中。</li>
<li>以页或段位单位的对换，称为页面对换或分段对换，又称为部分对换，他们是实现虚拟存储器的基础。</li>
<li>操作系统需要实现：兑换空间管理（提高换入换出速度），进程的换入，进程的换出。</li>
</ul>
</li>
</ol>
<h3 id="4-基本分页储存管理方式"><a href="#4-基本分页储存管理方式" class="headerlink" title="4.基本分页储存管理方式"></a>4.基本分页储存管理方式</h3><p>　　可重定位分区分配的每次紧凑都是有代价的，会导致内存在较长一段时间内无法使用，引用分页出从后，可以将作业离散地存放在内存中，从而使系统无需紧凑，很好的解决了外部碎片问题，但是也会产生页内碎片。</p>
<ul>
<li>注意：这种常规的分页储存管理方式中，整个内存只有有一张页表，不同于虚拟内存技术。</li>
</ul>
<ol>
<li><strong>基本方法</strong>：将进程逻辑地址空间分成若干大小相等的页，将内存分成若干个与页相同大小的块，称为物理块或页框。内存分配以块为单位，页面大小通常设置位2的幂，宏观上就是将原有的逻辑地址分为了两部分，高地址成为页号，低地址成为页内的位移量（或页内地址），程序访问内存时在页表中寻找页框（实际的物理块号），加上页内偏移得到实际物理地址。<ul>
<li>理论上程序可以使用全部内存，因此每一个进程都需要拥有一个映射全部内存的页表，独一无二的页表实现了逻辑地址的任意性，而且页表必须是连续的，否则会增加查找页表的开销。</li>
</ul>
</li>
<li><strong>地址变换</strong>：逻辑地址到物理地址的转换实在进程执行的过程中由硬件地址变换机构借助于页表自动实现的。通常是页表寄存器读入PCB中页表的内存起始位置和页表长度，当进程要访问某个逻辑地址中的指令后数据时，地址变换机构自动地将逻辑地址分为页号和页内地址两部分，并将页号与页表寄存器中的页表长度进行比较，若页号不小于页表长度，便产生越界中断，否则便以页号检索页表，从中得到物理块号拼接页内地址形成物理地址。<ul>
<li>上面叙述的越界中断是指一个内存只有一张页表，并未引入虚拟内存概念。</li>
</ul>
</li>
<li><strong>快表</strong>：一级页表结构下读一次内存需要先访问一次页表才能找到物理内存，由于页表也放在内存中，因此每次都要访问两次内存。因此增加一个具有并行查找能力的高速缓冲寄存器，又称联想储存器或快表（TLB，Translation lookaside buffer），用于存放当前被频繁访问的页面的页号和对应的页表项。地址转换时，先并行查找快表中是否由存有该页对应的物理块号，没有则再到内存读页表，将性的页表项于页号一起装入到快表中，若快表已满，则还需要根据置换算法淘汰某个快表项，以装入新的内容。<ul>
<li>成本原因导致快表一般只能存放61~1024个页表项，如果快表的命中率时a，访问一次内存的时间为t，访问快表的时间为k，则通过逻辑地址访问内存的有效访问时间为：<code>a*k + (1-a)(t+k) + t</code>。</li>
<li>程序的局部性使得快表的命中率可高达90%，因此可将快表造成的速度损失减少到10%以下。</li>
</ul>
</li>
<li><strong>多级页表</strong>：由于页表支持的物理内存地址很大（32bits -&gt; 4G，64bits -&gt; 16777216T），整张页表也会非常大，找到一个连续完整的大块内存比较困难，因此采用多级页表原理，本质是将页表离散储存在内存中，通过外层页表引用，便可以将内层页表分散的储存在内存中。虚拟存储器技术由于是一个作业一张表的原理，页表的占用的空间大大增多，因此未加使用内层页表可以不储存在内存中，由于外层页表的存在，整张页表仍然是连续的且完整的，一旦访问了不存在的内层页表，再将其移入内存中即可。<ul>
<li>宏观上多级页表就是将逻辑地址多分了几个部分，分别存放多级列表，现在的64位机器都会有很多级页表的存在。</li>
<li>访问多级页表必然会增加内存访问次数，降低访问时间，除了使用快表外，本质上还是一种时间换空间的做法。</li>
</ul>
</li>
</ol>
<h3 id="5-分段式储存管理方式"><a href="#5-分段式储存管理方式" class="headerlink" title="5.分段式储存管理方式"></a>5.分段式储存管理方式</h3><p>　　分页系统虽能较好的解决动态分区的碎片问题，却难以满足用户对段的需要，也不方便支持动态链接技术，因此引入分段式储存管理方式。</p>
<ol>
<li><strong>基本原理</strong>：与分页储存相同，只不过将分配对象由整个程序变为段。分段系统将每一个用户程序分成若干个段，包含段名段长，都采用首地址位0的一段连续地址空间，并且使用段表来储存该段在内存中的起始地址（又称为基址）和段的长度以及对应分段进行保护的存取控制信息。地址变换还是采用一个段表寄存器，用于存放正在执行进程的段表起始地址和长度（这里的常规分段式储存管理是直接布置在内存中的，因此会有越界中断）<ul>
<li>与一级分页系统一样，每访问一个数据也需要访问两次内存，因此分段系统也要使用快表来提高访问的速度。</li>
</ul>
</li>
<li><strong>分页与分段比较</strong>：分页系统和分段系统有许多相似之处，比如：都采用离散分配方式来提高内存利用率，都要通过地址变换机构来实现地址变换。但在概念上两者是完全不同的，它们的区别主要表现在以下三个方面：<ul>
<li>页是信息的物理单位，分页是为了提高内存的利用率。段则是信息的逻辑单位，它含有一组其意义相对完整的信息。分段是为了能更好地满足用户的需要。</li>
<li>页的大小固定且由系统决定。段的长度不固定，且由用户所编写的程序决定。</li>
<li>分页的地址空间是一维的，程序员只需利用一个记忆符，便可表示一个地址。分段的地址空间是二维的，程序员在标识一个地址时，既需给出段名，又需给出段内地址。</li>
</ul>
</li>
<li><strong>段页式储存管理方式</strong>：将地址空间中的用户程序分成若干个段，再将每个段分为若干个页，进行地址变换时，首先通过段表寄存器中的段表起始地址和逻辑地址中的段号找到对应的段表项，从中获得该段的页表起始地址，然后再利用页表起始地址和段内页号来获得对应的页表项，从中获取该页的内存块号，与业内地址拼接成物理地址。<ul>
<li>每次存取都需要三次访问内存，所以可在地址变换机构中增设快表，用来存放当前被频繁访问的页面所对应的段号、段内页号和物理块号等信息。</li>
</ul>
</li>
</ol>
<h3 id="6-信息共享"><a href="#6-信息共享" class="headerlink" title="6.信息共享"></a>6.信息共享</h3><p>　　分页系统通过将共享页对应的页表项指向同一个内存块来实现信息共享，但是由于分页由系统自动进行，会造成共享代码或数据与非共享代码或数据共处一页的情况，是其信息共享十分困难。而分段由于具有相对完整的意义，因此可以通过共享段更容易的实现信息共享。</p>
<h2 id="虚拟存储器"><a href="#虚拟存储器" class="headerlink" title="虚拟存储器"></a>虚拟存储器</h2><hr>
<h3 id="1-引入"><a href="#1-引入" class="headerlink" title="1.引入"></a>1.引入</h3><ol>
<li>常规存储管理方式的特征：<ul>
<li><strong>一次性</strong>（作业必须再运行前一行全部装入内存才能开始运行）</li>
<li><strong>驻留性</strong>（许多再程序运行中不用或暂时不用的程序或数据占据大量的内存空间，使得一些需要运行的程序无法装入内存；若一个程序要求的内存空间超过了内存实际容量，则该程序必定无法装入内存运行）</li>
</ul>
</li>
<li>由于程序局部性原理，可以引入虚拟储存器：<ul>
<li><strong>时间局部性</strong>（程序的循环操作）</li>
<li><strong>空间局部性</strong>（程序的顺序执行）</li>
</ul>
</li>
</ol>
<h3 id="2-虚拟储存器的主要特征"><a href="#2-虚拟储存器的主要特征" class="headerlink" title="2.虚拟储存器的主要特征"></a>2.虚拟储存器的主要特征</h3><ol>
<li><strong>多次性</strong>：虚拟储存器将一个作业分成多次调入内存，这也是虚拟存储器最重要的特征。</li>
<li><strong>对换性</strong>：作业运行期间，虚拟存储器允许将那些暂不使用的程序或数据从内存调至对换区，待以后需要时再调入内存，有效提高内存利用率。</li>
<li><strong>虚拟性</strong>：虚拟存储器对内存的扩充是逻辑上的，用户所看到的大容量是虚拟的，虚拟性是实现虚拟存储器的目标。</li>
</ol>
<ul>
<li><strong>所需支持</strong>：系统必须具有一定容量的内存和较大容量的外存，必须提供请求分页（段）的页（段）表机制，以及缺页（段）中断机构和地址变换机构；还需要实现请求调页（段）的软件以及实现页（段）置换的软件的支持。</li>
</ul>
<h3 id="3-页表结构"><a href="#3-页表结构" class="headerlink" title="3.页表结构"></a>3.页表结构</h3><ul>
<li><strong>内存块号</strong></li>
<li><strong>状态位 P</strong>（中断位，存在位，驻留位）：指示该页是否已调入内存</li>
<li><strong>访问字段 A</strong>：记录最近一段时间被访问次数或未被访问时间，用于置换算法实现</li>
<li><strong>修改位 M</strong>：表示该页再调入内存后是否被修改过，换出时确定是否重新写回外存</li>
<li><strong>外存地址</strong>：用于从外存调入页面</li>
</ul>
<h3 id="4-过程与策略"><a href="#4-过程与策略" class="headerlink" title="4.过程与策略"></a>4.过程与策略</h3><p>访问未调入内存的页，产生缺页中断，缺页中断程序检查是否有空闲的内存块，有则直接调入，无则根据置换算法淘汰内存中的某一页，若被淘汰的页已被修改过，需要重新写回外存。</p>
<ul>
<li><strong>固定分配局部置换策略</strong>：为进程分配固定数量的物理块，换入换出只能在这部分物理块上实现，未考虑进程的动态性。</li>
<li><strong>可变分配全局置换策略</strong>：先分配一定数量的物理块，缺页时可以全局分配新的物理块，因此置换可能导致其他进程的缺页率增加。</li>
<li><strong>可变分配局部置换策略</strong>：缺页时只能换出自己的内存页，若缺页率超过阈值，则再分配附加物理块，直到缺页率减少的适当程度为止，反之缺页率特别低的进程可以适当减少分配给他的物理块。因此可获得较高的内存利用率，同时又能保证每个进程有较低的缺页率。</li>
</ul>
<h3 id="5-调页策略"><a href="#5-调页策略" class="headerlink" title="5.调页策略"></a>5.调页策略</h3><ol>
<li><strong>请求调页策略</strong>：正常的调页流程，效果是进程在刚启动时，缺页中断会发生的比较频繁，由于程序访问的局部性，一段时间后缺页率会降至较低。一个被整体换出的进程重新开始执行时，也具有上述情况。</li>
<li><strong>预调页策略</strong>：预计在不久之后便会访问到的几个页面并将其预先调入内存的策略。预测的难度高，成功率只有50%，因此主要应用于进程首次调入和整体换入时，由程序员或系统指出应该先调入哪些页面，这样可以使得刚开始执行的进程缺页率明显降低。</li>
</ol>
<h3 id="6-置换算法"><a href="#6-置换算法" class="headerlink" title="6.置换算法"></a>6.置换算法</h3><ul>
<li><strong>抖动</strong>：在虚存中，页面在内存与外存之间频繁调度，以至于调度页面所需时间比进程实际运行的时间还多，此时系统效率急剧下降，甚至导致系统崩溃。这种现象称为颠簸或抖动**</li>
</ul>
<ol>
<li><strong>最佳（OPT, Optimal）</strong>：选择以后不再使用或最长时间内不再被访问的内存页面予以淘汰。这是一个理论上的算法，常用来评价其他算法的优劣。</li>
<li><strong>先进先出（FIFO, First In First Out）</strong>：与程序的局部性不相符，实际应用很少使用纯粹的FIFO。</li>
<li><strong>最近最久未使用（LRU, Least Recently Used）</strong>：LRU赋予每一个页面一个访问字段，记录相应页面自上次被访问以来所经历的时间，淘汰时选择时间最长的页面，但是为了快速判断哪一页是最近最久未用的页面，他需要较多的硬件支持，增加系统成本，故实际应用中，大多数只采用LRU的近似算法。<ul>
<li>Clock算法：置被访问页的访问位为1，然后从该页开始扫描，若访问页为1，置为0，若为0，则直接换出。考虑到重写磁盘成本，因此可以选择首个访问位和修改位均为0（0，0）的页面换出，若无可以进行二次扫描选择（0，1）的页面换出。可以重复进行扫描。</li>
</ul>
</li>
<li><strong>最少使用（LFU, Least Frequently Used）</strong> ：同理需要得到较多硬件支持，而且对于新调入的页可能因为访问较少而被换出，而另一些页面因为在某个时候被访问多次，即使以后不再使用，也不会马上被淘汰，从而使LFU算法性能不佳，因此并不常用。</li>
<li><strong>页面缓冲算法（PBA, Page Buffering Algorithm）</strong>：被换出的页面仍然留在内存的空闲块中，所有的空闲块形成一个空闲页面缓冲池，因此发生缺页时，如果能从空闲页面缓冲池找到所缺的页，则直接可将对应的物理块分配给进程而无需启动磁盘I/O，若无，则为缺页分配一个空闲块并将所缺的页读入其中；同时按照某种置换算法选择一个淘汰页，，该淘汰也所占用的内存块被作为空闲块，加入到空闲页面缓冲池。有的系统如VAX/VMS，还根据淘汰也是否需要写回磁盘将空闲块组织成空闲页面量表和修改页面链表，每次分配内存块时总是将空心啊页面面链表中的第一个物理块分配出去，而当修改页面链表的空闲块达到一定数量时，再将其一起写回磁盘，以减少磁盘I/O次数，提高系统效率。</li>
</ol>
<h3 id="7-请求分段储存管理方式"><a href="#7-请求分段储存管理方式" class="headerlink" title="7.请求分段储存管理方式"></a>7.请求分段储存管理方式</h3><p>​    当然虚拟内存也支持请求分段的管理方式，与请求分页系统类似，在分段的基础上增加请求调段功能和段置换功能，便可形成具有虚拟存储器功能的请求分段系统。也可通过建立共享段表使系统分配同一个物理地址来实现分段共享。当然也需要进行分段的保护，常用如越界检查、存取控制检查、环保护机制的方法实现分段保护</p>
<h3 id="8-段页结合的实际内存管理"><a href="#8-段页结合的实际内存管理" class="headerlink" title="8.段页结合的实际内存管理"></a>8.段页结合的实际内存管理</h3><p>​    <strong>虚拟内存</strong>：我们让应用程序分为段，然后映射到一段虚拟内存中，再让虚拟内存映射到物理内存中的页中，这样就完成了段和页的结合。</p>
<p>使用内存分为五步：</p>
<ul>
<li>分配段</li>
<li>建段表</li>
<li>分配页</li>
<li>建页表</li>
<li>重定位</li>
</ul>
<h2 id="输入输出系统"><a href="#输入输出系统" class="headerlink" title="输入输出系统"></a>输入输出系统</h2><hr>
<p>​    I/O系统是用于实现数据输入、输出和存储的系统，最主要的任务是完成用户提出的I/O请求、提高I/O速率以及改善设备的利用率，并为更高层的进程方便地使用I/O设备提供手段。</p>
<h3 id="1-基本功能"><a href="#1-基本功能" class="headerlink" title="1.基本功能"></a>1.基本功能</h3><ol>
<li><strong>隐藏物理设备的细节</strong>：I/O设备不仅种类繁多，而且它们的特性和操作方式往往也存在很大差异，为了方便用户使用I/O设备，I/O系统必须对I/O设备进行适当的抽象，以隐藏掉物理设备的实现细节，而统一向用户提供少量的、抽象的读/写命令。</li>
<li><strong>与设备的无关性</strong>：允许应用程序通过抽象的逻辑设备名来请求使用某类设备，使得应用程序独立于具体使用的物理设备，从而有效地提高OS的可移植性和易适应性。</li>
<li><strong>提高处理机和I/O设备的利用率</strong>：应尽量减少处理机对I/O设备的干预，提高处理机和I/O设备并行操作的程度，以提高它们的利用率。</li>
<li><strong>对I/O设备进行控制</strong>：通过设备驱动程序启动I/O设备进行数据传输，并能对数据传输方式进行有效的控制。</li>
<li><strong>确保对设备的正确共享</strong>：对不同类型的设备应采用不同的分配方式，以保证多个进程能共享设备进行正确的I/O操作。</li>
<li><strong>错误处理</strong>：相对于系统的其他部分，I/O设备运行时更容易出现错误，而且这些错误很多是与设备紧密相关的，因此对于这类错误，应该尽可能在接近硬件的层面上处理，只有低层软件解决不了的错误才需向上层报告，请求上层软件解决。</li>
</ol>
<h3 id="2-层次结构"><a href="#2-层次结构" class="headerlink" title="2.层次结构"></a>2.层次结构</h3><ol>
<li>用户层I/O软件</li>
<li>设备独立性软件</li>
<li>设备驱动程序</li>
<li>中断处理程序</li>
</ol>
<h3 id="3-I-O硬件"><a href="#3-I-O硬件" class="headerlink" title="3.I/O硬件"></a>3.I/O硬件</h3><ol>
<li><p><strong>I/O设备</strong></p>
<ul>
<li>按信息交换的单位分类：块设备（速度高可寻址）、字符设备（速度低不可寻址）</li>
<li>按使用特性分类：储存设备、I/O设备</li>
<li>按传输速率分类：低速设备、中速设备、高速设备</li>
</ul>
</li>
<li><p><strong>设备控制器</strong></p>
<p>​    设备控制器是CPU和I/O之间的硬件接口，他接收从CPU发来的命令。并去控制一个或多个设备，在微型机和小型机中，他通常是一块可以插入主板扩展槽的印刷电路板，也叫接口卡。</p>
<p>​    设备控制器通过一组寄存器来沟通CPU和I/O，CPU通过向其中的控制寄存器写命令来执行I/O操作，如果某个命令带有参数，则还需要将这些参数写道控制器的相应寄存器中。接收到命令后，设备控制器将按命令的要求独立的去控制指定的设备的输入/输出，CPU便可去执行其他工作。输入/输出的完成情况与设备的状态信息均由控制器存放在自己的状态寄存器中，当控制器完成与设备之间的数据交换后，他将产生一个中断。CPU可通过读取寄存器来获得操作结果和设备的状态。</p>
<p>​    为了平衡速度差距，控制器中须设置一些数据缓冲寄存器，用于缓冲CPU向外的输出和IO向内的输入。</p>
</li>
<li><p><strong>I/O寄存器的访问方式</strong></p>
<ul>
<li><strong>I/O端口号</strong>：使用I/O指令来读写设备控制器内的寄存器。</li>
<li><strong>内存映射I/O</strong>：I/O寄存器作为内存地址空间的一部分，该地址不会被分配给内存单元，可以采用与访问内存同样的方式来访问I/O寄存器。</li>
</ul>
</li>
<li><p><strong>I/O通道</strong></p>
<p>​    在许多大、中型计算机系统中，I/O管理工作交给了一个专门的部件，即I/O通道。其作为一个独立于主机CPU的专门用来管理I/O的特殊处理机，有着自己的指令系统，其指令称为通道指令。通道指令主要局限于与I/O操作相关的指令，通道所执行的程序被称为通道程序，由于通道不带内存，故通道程序被存放在主机的内存中。通道有自己的总线控制部分，可以控制设备与内存直接进行数据交换。</p>
</li>
</ol>
<h3 id="4-中断及中断处理程序"><a href="#4-中断及中断处理程序" class="headerlink" title="4.中断及中断处理程序"></a>4.中断及中断处理程序</h3><ol>
<li><p><strong>中断</strong></p>
<p>​    中断是指CPU在执行一个程序时，对系统中发生的某个事件作出的一种反应：CPU暂停正在执行的程序，保留现场后自动转去处理相应的事件，处理完该事件后，到适当的时候返回断点，继续完成被打断的程序。中断在操作系统中有着重要的地位，它是多道程序得以实现的基础。<br>​    根据引起中断的事件的不同类型，可将中断分为外部中断（简称中断）和陷入（又叫异常）两种，前者是由CPU以外的外部事件引起的，如I/O设备引起的I/O中断；后者是CPU执行指令过程中检测到的一些内部事件引起的，如非法指令、地址越界等引起的中断。<br>​    每一种中断或陷入都有一个与之相联系的中断号，并有一个与之相联系的中断处理程序，CPU通过执行相应的中断处理程序来完成对应事件的处理。为了处理上的方便，每种中断或陷入的中断处理程序按中断号的顺序存放在一张中断向量表或中断描述符中。在中断响应时，系统会根据中断号去查找中断向量表或中断描述符表，从中获得相应的中断向量表处理程序的入口地址，这样便可以转入中断处理程序执行。</p>
</li>
<li><p><strong>I/O中断处理程序工作流程</strong></p>
<p>（1）<strong>检查本次I/O操作的完成情况</strong>：中断处理程序通过读设备控制器的状态寄存器来检查本次/O操作的完成情况。<br>（2）<strong>进行I/O结束或错误处理</strong>：若本次操作成功，则进行结束处理。譬如，本次操作是字符设备的读操作，即中断来自某个进行输入的字符设备，那说明该设备已经读入了一本字符（字）的数据，并已将该数据放入数据寄存器中。此时中断处理程序应将该数据传送给CPU，再将它存入缓冲区中，并修改相应的缓冲区指针，使其指向下一个内存单元。否则，根据发生异常的原因做相应的处理，在某些情况下，还需要按重试次数调用设备驱动程序重新传送数据。I/O执行的最终结果，也将由中断处理程序向上层软件汇报。<br>（3）<strong>唤醒被I/O操作阻塞的进程</strong>：I/O中断处理程序还必须唤醒等待本次I/O完成的相应进程，以使它能继续向前推进。<br>（4）<strong>启动下一个请求</strong>：若请求I/O的队列中还有其他I/O请求等待处理，则调用设备驱动程序进行新一轮的数据传送。<br>（5）<strong>中断返回</strong>：执行中断返回指令进行中断返回。</p>
</li>
</ol>
<h3 id="5-设备驱动程序"><a href="#5-设备驱动程序" class="headerlink" title="5.设备驱动程序"></a>5.设备驱动程序</h3><p>设备驱动程序是I/O进程与设备控制器之间的通信程序，它接收来自上层软件的、抽象的I/O命令，再把它转换成具体要求后，发送给设备控制器，从而启动设备进行数据传送。设备驱动程序的处理过程如下：<br>（1）<strong>将抽象要求转换成具体要求</strong>：操作系统对用户屏蔽了有关物理设备的具体细节，并提供给用户一个一致的I/O接口，因此，用户进程或上层软件发出的I/O请求通常只是一些抽象的命令，驱动程序必须将这些命令按设备控制器所要求的格式转换成具体的命令，如将read命令中的盘块号按地址寄存器的格式转换成盘面、磁道及扇区号。<br>（2）<strong>检查I/O请求的合法性</strong>：每种设备都只能完成一组特定的功能，设备驱动程序必须检查用户提出的I/O请求，若相应设备不支持这次I/O请求，则认为这次I/O请求非法。对某些设备，如磁盘上的文件操作，若它们的打开方式是读，则认为用户的写请求是非法的，因此必然被拒绝。<br>（3）<strong>读出和检查设备的状态</strong>：在启动设备之前，驱动程序要从设备控制器的状态寄存器中读出设备的状态，仅当它处于就绪状态时，才能启动其设备控制器，否则只能将相应的I/O请求插入请求I/O的队列。<br>（4）<strong>传送必要的参数</strong>：对带有参数的I/O命令，驱动程序必须将这些参数，如读盘时的磁盘地址、内存地址、本次要传送的字节数等，传送到设备控制器的相应寄存器中。对于字符设器，若发出的是写命令，驱动程序还必须把输出数据写入控制器的数据寄存器。有些设备可具有多种工作方式，典型的情况是利用RS-232接口进行异步通信，在启动该接口之前应该先按通信规程设定下述参数：波特率、奇偶校验方式、停止位数及数据字节长度等。<br>（5）<strong>启动I/O设备</strong>：在完成上述各项准备工作后，驱动程序可以向控制器的命令寄存器传送相应的命令，启动I/O设备开始I/O操作。</p>
<ul>
<li>驱动设备发出I/O命令后，基本的I/O操作是在设备控制器的控制下进行的。通常I/O操作所要完成的工作需要一定的时间，因此执行驱动程序的进程便把自己阻塞起来，直到I/O中断到来时才被唤醒。</li>
</ul>
<h3 id="6-I-O控制方式"><a href="#6-I-O控制方式" class="headerlink" title="6.I/O控制方式"></a>6.I/O控制方式</h3><ol>
<li><strong>轮询</strong></li>
<li><strong>中断</strong></li>
<li><strong>直接存储器访问（DMA）</strong></li>
<li><strong>I/O通道控制</strong></li>
</ol>
<h3 id="7-与设备无关的I-O软件"><a href="#7-与设备无关的I-O软件" class="headerlink" title="7.与设备无关的I/O软件"></a>7.与设备无关的I/O软件</h3><ol>
<li><p>概念：应用程序与具体使用的物理设备无关。设置LUT逻辑设备表，应用程序按逻辑设备名称来请求使用某类设备。</p>
</li>
<li><p>设备独立性软件：在设备驱动程序之上设置的一层软件，首先是执行所有设备的公共操作，包括：缓冲管理、差错控制、对独立设备的分配和回收、提供独立于设备的逻辑数据块、逻辑设备到物理设备的映射、设备的保护等；其次是向用户层软件提供一个设备驱动程序的统一接口。</p>
</li>
<li><p>设备分配</p>
<p>（1）<strong>设备分配中的数据结构</strong></p>
<ul>
<li><strong>设备控制表（DCT）</strong>：每个设备有一张DCT，用于记录相应设备的各种属性，包含设备类型、设备标识符、设备状态、设备等待队列指针、与设备连接的控制器的COCT指针、重复执行次数等。</li>
<li><strong>控制器控制表（COCT）</strong>：用于记录控制器情况</li>
<li><strong>通道控制表（CHCT）</strong>：用于记录通道情况</li>
<li><strong>系统设备表（SDT）</strong>：每个设备占SDT的一个表目，包含设备类型、设备表示符、设别控制表指针与设备驱动程序入口地址等。</li>
</ul>
<p>（2）<strong>独占设备的分配程序</strong></p>
<ul>
<li>当某进程提出I/O请求后，设备分配程序首先根据进程给出的物理设备名，查找SDT，从中找到该设备的DCT；在检查DCT中的设备状态字段，若设备处于忙状态，则将请求I/O的进程插入设备等待队列；否则便按照一定的算法来计算本次设备分配的安全性，若分配不会导致系统进入不安状态，便将该设备分配给请求进程，否则仍将该进程插入设备等待队列。</li>
<li>设备分配成功后，设备分配程序将通过DCT找到与该设备相连接的控制器的COCT，检查COCT的状态字段，若控制器忙，不变将球球进程插入扣扣内阁制其等待队列；否则便将该控制器分配给请求进程。</li>
<li>分配控制器后，通过COCT又可以i找到与该控制器连接的通道的CHCT，进行通道的分配，只有在设备、控制器和通道三者都分配成功时，这次设备的分配才算成功，然后系统便可启动该设备进行数据传送。</li>
</ul>
<p>4.缓冲管理</p>
<ul>
<li>可以显著的提高CPU和I/O设备之间的并行操作程度</li>
<li>引入缓冲区还可以协调传输数据大小不一致的设备，很好的解决数据粒度不匹配的问题</li>
</ul>
</li>
</ol>
<h3 id="8-用户层的I-O软件"><a href="#8-用户层的I-O软件" class="headerlink" title="8.用户层的I/O软件"></a>8.用户层的I/O软件</h3><ol>
<li><p><strong>I/O库函数</strong></p>
</li>
<li><p><strong>假脱机（SPOOLing）系统</strong></p>
<ul>
<li>将一台独占的物理设备虚拟为多台逻辑设备，从而使该物理设备可被多个进程同时共享</li>
</ul>
<p>（1）<strong>SPOOLing系统组成</strong></p>
<ul>
<li><p>输入井和输出井</p>
</li>
<li><p>输入缓冲区和输出缓冲区</p>
</li>
<li><p>输入进程和输出进程</p>
</li>
<li><p>井管理程序</p>
</li>
</ul>
<p>（2）<strong>假脱机打印系统</strong></p>
<ul>
<li>利用SPOOLing技术可将独占的打印机改造为一台共多个用户共享的设备，这种共享打印机技术已被广泛的用于多用户系统和局域网络中。</li>
<li>相应操作：在输出井中位置申请一个空闲的磁盘块区，并将要打印的数据送入其中；位用户进程申请一张空白的用户请求打印表，并将用户的阿银要求填入其中，让后将该表挂到假脱机文件队列上。</li>
</ul>
</li>
</ol>
<h3 id="9-磁盘调度"><a href="#9-磁盘调度" class="headerlink" title="9.磁盘调度"></a>9.磁盘调度</h3><ul>
<li>磁盘实际访问时间由<code>寻道时间</code>、<code>旋转延迟时间</code>、<code>传输时间</code>三部分组成。对于大多数磁盘，寻道时间站其中的大部分，所以减少平均寻道时间可以显著的改善磁盘系统的性能。</li>
<li>磁盘调度<ol>
<li><strong>先来先服务（FCFS）</strong></li>
<li><strong>最短寻道时间有限（SSTF）</strong>：每次寻道时间最短并不能保证平均寻道时间最短，而且在当前磁道附近不断有新的I/O请求到来时，还可能使要求访问较远磁道的进程产生饥饿现象。</li>
<li><strong>扫描（SCAN）</strong>：也叫电梯调度算法，他选中的是当前磁头移动方向上、距离当前磁头所在的磁道最近的磁道上的请求。SCAN算法既能获得较好的寻道性能，又能防止饥饿现象，故广泛用于大中小型机器和网络中。</li>
<li><strong>循环扫描（CSCAN）</strong>：SCAN磁头移动时，若恰好对越过的磁道进行访问，则必须等待磁头移动到另一端反向回来才可以访问。为了减少这种延时，规定只在磁头移动的某一个方向上处理磁盘请求，因此当沿着该方向访问到最远的一个请求后，磁臂立即返回到磁盘的另一端，并再次开始扫描（说的很高大上，其实就是单方向扫描）</li>
<li><strong>N-step-SCAN</strong>：当进程对某一磁道有较高的访问频率时，利用前面几个算法都可能出现磁臂停留在磁道上不动的情况，这种现象被称为“磁臂粘着”，N-step-SCAN将磁盘请求队列按请求到达的时间先后顺序分成若干个长度为N的子队列，并采用FCFS算法依次处理这些子队列，而对于每个子队列，则又是按SCAN算法进行处理。</li>
<li><strong>FSCAN</strong>：实质上是N-step-SCAN的简化，他只把磁盘请求队列分成两个子队列，一个是当前所有请求磁盘I/O的进程形成的队列，由磁盘调度按SCAN算法进行处理；在扫描期间到达的所有请求磁盘I/O的进程，被放入另一个等待处理的请求队列。这样所有的新请求都将被推迟到下一次扫描时处理。</li>
</ol>
</li>
</ul>
<h2 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h2><hr>
<h3 id="1-文件和文件系统"><a href="#1-文件和文件系统" class="headerlink" title="1.文件和文件系统"></a>1.文件和文件系统</h3><ol>
<li><strong>文件的定义</strong>：文件是具有文件名的一组相关信息的集合，通常是由ASCII码+/汉字组成。文件的基本内容可以由零或多个字节构成；这些字节可以是简单的字符流，也可以是一个或多个记录的集合，他们的具体含义由文件的创建者和使用者解释。每个文件除了文件名和基本内容以外，还应具有自己的属性，具体的属性可以包括：文件类型、文件长度、文件的物理位置、文件的建立时间等，他们也必须保存在文件储存器中。</li>
<li><strong>文件系统模型</strong><ul>
<li>文件系统的接口</li>
<li>对对象操作和管理的软件集合</li>
<li>对象及其属性</li>
</ul>
</li>
<li><strong>文件的使用</strong>：创建、删除、读、写、设置文件的读/写指针、打开、关闭。</li>
</ol>
<h3 id="2-文件的逻辑结构"><a href="#2-文件的逻辑结构" class="headerlink" title="2.文件的逻辑结构"></a>2.文件的逻辑结构</h3><ol>
<li><p><strong>有结构文件</strong></p>
<p>有结构文件也称记录式文件，其数据的组成可分为数据项、记录和文件三级。</p>
<ul>
<li>顺序文件：串结构文件（按存入先后顺序排列）；顺序结构文件（按关键字的次序排列）。一般记录为定长记录，故其通常具有较快额记录检索速度。</li>
<li>索引文件：当记录为可变长度时，通常采用索引文件的方式，他为每一个文件建立一张索引表，并将主文件的每个记录的记录号（或关键字）、长度和逻辑地址记录在索引表中。由于索引表本身是一个定长记录文件，因此可以十分方便的检索到相应记录的索引表想，从而可方便的对主文件中的记录实现直接存取。</li>
<li>索引顺序文件：是上述二者结合，记录按顺序方式组织，每个文件也需要建立一张索引表，但是只需要为主文件的每一组记录的第一个记录设置一个索引表项，因此能有效地减少索引表所占的空间。</li>
</ul>
</li>
<li><p><strong>无结构文件</strong></p>
<p>​    无结构文件是指由字符流构成的文件，故又称流式文件。流式文件的基本单位是字节，因此可以将它看作是记录式文件的一个特例。在很多操作系统中，如UNIX系统，所有的文件都被看成是流式文件。在创建和使用流式文件时，虽然操作系统只讲他看成是一个字符流，但用户仍然可以按自己的需要赋予文件某种结构。</p>
</li>
</ol>
<h3 id="3-文件目录"><a href="#3-文件目录" class="headerlink" title="3.文件目录"></a>3.文件目录</h3><ol>
<li><p><strong>文件控制块、目录项和索引节点</strong></p>
<p>​    文件控制块（FCB）是OS用来描述和控制文件的一个数据结构，其中包含文件名、文件物理地址，通常还有文件的逻辑结构、文件的物理结构、文件的长度、存取权限、建立日期和时间、最后一次修改的日期和时间、我呢见的连接计数及文件主标识符等文件属性信息。  </p>
<p>​    文件控制块与文件一一对应，问及那控制块的有序集合被称为目录，其中每个文件控制块被称为目录项。目录通常也是以稳健的方式存放在外存上，故也被称为目录文件。</p>
<p>​    有些系统如UNIX系统，便采用把文件和文件描述信息分开的办法，即将文件描述信息单独形成一个称为索引节点的数据结构，存放在外存的索引节点区，而组成问及那目录的目录项中仅有文件名和指向该文件所对应的索引结点的指针。这样，便可以大大减少文件目录所占的磁盘块数，从而加快检索目录的速度。</p>
</li>
<li><p><strong>目录结构</strong></p>
<ul>
<li>单级目录结构：概念性的东西</li>
<li>两级目录结构：为多个用户提供单独的用户文件目录</li>
<li>多级目录结构：又称树形目录结构</li>
</ul>
</li>
<li><p><strong>目录查询技术</strong></p>
<p>​    目标目录的文件分量词与目录树的每层分别比较，这里不再赘述。</p>
</li>
</ol>
<h3 id="4-文件共享"><a href="#4-文件共享" class="headerlink" title="4.文件共享"></a>4.文件共享</h3><ol>
<li><strong>基于索引节点的共享方式</strong><ul>
<li>通过链接计数实现，创建索引指针链接数加一，为零则删除。</li>
<li>文件主无法直接删除自己的文件。</li>
</ul>
</li>
<li><strong>利用符号链实现文件共享</strong><ul>
<li>通过建立LINK文件实现，该文件只包含了被链接文件的路径名，一旦访问LINK类型文件将被OS截获，根据文件中的路径名去读那个文件。</li>
<li>只要简单提供一个机器的网络地址以及文件在该机其中的文件路径名，便可链接全球任一处机器上的文件。</li>
<li>其他用户访问共享文件必须根据路径中的分量名逐级的去检索目录，加大了访问文件的开销。</li>
<li>尽管LINK类型文件十分简单，但仍需要为它配置一个索引节点，并分配一个盘块来存放被链接文件的路径名，同样会增加系统开销。</li>
</ul>
</li>
</ol>
<h3 id="5-文件保护"><a href="#5-文件保护" class="headerlink" title="5.文件保护"></a>5.文件保护</h3><p>​    安全性背景：人为因素、系统因素、自然因素（随时间推移，存放在磁盘上的数据会逐渐消失），先在本章讨论人为因素。</p>
<ol>
<li><p><strong>访问权和保护域</strong></p>
<ul>
<li>访问权是一个用户（进程）对某个对象执行操作的权利，它可以用一有序对 （对象名、权集）来表示。</li>
<li>保护域，简称域，是用户（进程）对一组对象的访问权的集合。</li>
</ul>
<p>​    进程和域之间的联系可以是静态的，因此在整个生命期中，进程只能在一个域中运行。进程和域之间的联系也可以是动态的，即在进程运行的不同阶段，允许他通过保护域切换功能，从一个域切换到另一个域。</p>
</li>
<li><p><strong>访问矩阵</strong></p>
<p>​    访问矩阵用来描述系统的访问控制的一张二维表，其行代表一个保护域，列代表系统中的一个对象，矩阵中的每一项是由一组访问权组成的，它定义了在行所代表的域中的执行的进程，能对列所代表的对象施加何种操作。若进程和域之间采用动态的联系方式，便可以在矩阵中增加域本身，表示进程是否可以切换到其他域中运行。</p>
</li>
<li><p><strong>访问矩阵的实现</strong></p>
<p>​    由于域的数量和对象的数量都可能很大，需要减少访问矩阵的空间开销和访问该矩阵的时间开销。</p>
<ul>
<li>访问控制表：是访问矩阵按列划分去掉空项形成的。其存放在文件对象的文件控制块中，其访问控制表可以作为文件存取控制信息。</li>
<li>访问权限表：是访问矩阵按行划分形成的。</li>
</ul>
<p>​    当一个用户（进程）第一次试图访问一个对象时，必须先检查访问控制表，如果用户（进程）不具有该对象的访问权，则由系统拒绝用户（进程）的访问，并构成一异常事件，否则便允许用户（进程）对该对象进行访问，并在用户（进程）的访问权限表中增加对该对象的访问权限。以后，该用户（进程）便可以直接利用这一返回的权限去访问该对象。</p>
</li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="https://lightship568.github.io">Lightship</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://lightship568.github.io/2021/08/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/">https://lightship568.github.io/2021/08/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/09/12/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/" title="加密算法"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">Previous</div><div class="prev_info">加密算法</div></div></a></div><div class="next-post pull-right"><a href="/2021/08/24/%E7%AE%80%E6%98%93%E6%B1%87%E7%BC%96%E5%85%A5%E9%97%A8/" title="简易汇编入门"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">Next</div><div class="next_info">简易汇编入门</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Lightship</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">8</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">3</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BC%95%E8%AE%BA"><span class="toc-number">1.</span> <span class="toc-text">操作系统引论</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%8F%91%E5%B1%95%E8%BF%87%E7%A8%8B"><span class="toc-number">1.1.</span> <span class="toc-text">1.发展过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%9F%BA%E6%9C%AC%E7%89%B9%E5%BE%81"><span class="toc-number">1.2.</span> <span class="toc-text">2.基本特征</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%8A%9F%E8%83%BD"><span class="toc-number">1.3.</span> <span class="toc-text">3.功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.4.</span> <span class="toc-text">4.结构设计</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%8F%8F%E8%BF%B0%E4%B8%8E%E6%8E%A7%E5%88%B6"><span class="toc-number">2.</span> <span class="toc-text">进程的描述与控制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">2.1.</span> <span class="toc-text">1.基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-number">2.2.</span> <span class="toc-text">2.进程控制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="toc-number">2.3.</span> <span class="toc-text">3.进程同步</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E7%BB%8F%E5%85%B8%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98"><span class="toc-number">2.4.</span> <span class="toc-text">4.经典进程同步问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E7%AE%A1%E7%A8%8B%E6%9C%BA%E5%88%B6"><span class="toc-number">2.5.</span> <span class="toc-text">5.管程机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1"><span class="toc-number">2.6.</span> <span class="toc-text">6.进程通信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E7%BA%BF%E7%A8%8B"><span class="toc-number">2.7.</span> <span class="toc-text">7.线程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6%E4%B8%8E%E6%AD%BB%E9%94%81"><span class="toc-number">3.</span> <span class="toc-text">处理机调度与死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6%E8%B0%83%E5%BA%A6%E5%B1%82%E6%AC%A1"><span class="toc-number">3.1.</span> <span class="toc-text">1.处理机调度调度层次</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">3.2.</span> <span class="toc-text">2.调度算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%AE%9E%E6%97%B6%E8%B0%83%E5%BA%A6"><span class="toc-number">3.3.</span> <span class="toc-text">3.实时调度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%AD%BB%E9%94%81"><span class="toc-number">3.4.</span> <span class="toc-text">4.死锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%A4%84%E7%90%86%E6%AD%BB%E9%94%81%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95"><span class="toc-number">3.5.</span> <span class="toc-text">5.处理死锁基本方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86"><span class="toc-number">4.</span> <span class="toc-text">储器管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%A3%85%E5%85%A5"><span class="toc-number">4.1.</span> <span class="toc-text">1.装入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%93%BE%E6%8E%A5"><span class="toc-number">4.2.</span> <span class="toc-text">2.链接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">4.3.</span> <span class="toc-text">3.连续分配方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%9F%BA%E6%9C%AC%E5%88%86%E9%A1%B5%E5%82%A8%E5%AD%98%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-number">4.4.</span> <span class="toc-text">4.基本分页储存管理方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%88%86%E6%AE%B5%E5%BC%8F%E5%82%A8%E5%AD%98%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-number">4.5.</span> <span class="toc-text">5.分段式储存管理方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E4%BF%A1%E6%81%AF%E5%85%B1%E4%BA%AB"><span class="toc-number">4.6.</span> <span class="toc-text">6.信息共享</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8"><span class="toc-number">5.</span> <span class="toc-text">虚拟存储器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%BC%95%E5%85%A5"><span class="toc-number">5.1.</span> <span class="toc-text">1.引入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%99%9A%E6%8B%9F%E5%82%A8%E5%AD%98%E5%99%A8%E7%9A%84%E4%B8%BB%E8%A6%81%E7%89%B9%E5%BE%81"><span class="toc-number">5.2.</span> <span class="toc-text">2.虚拟储存器的主要特征</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E9%A1%B5%E8%A1%A8%E7%BB%93%E6%9E%84"><span class="toc-number">5.3.</span> <span class="toc-text">3.页表结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E8%BF%87%E7%A8%8B%E4%B8%8E%E7%AD%96%E7%95%A5"><span class="toc-number">5.4.</span> <span class="toc-text">4.过程与策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E8%B0%83%E9%A1%B5%E7%AD%96%E7%95%A5"><span class="toc-number">5.5.</span> <span class="toc-text">5.调页策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="toc-number">5.6.</span> <span class="toc-text">6.置换算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E8%AF%B7%E6%B1%82%E5%88%86%E6%AE%B5%E5%82%A8%E5%AD%98%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-number">5.7.</span> <span class="toc-text">7.请求分段储存管理方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E6%AE%B5%E9%A1%B5%E7%BB%93%E5%90%88%E7%9A%84%E5%AE%9E%E9%99%85%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">5.8.</span> <span class="toc-text">8.段页结合的实际内存管理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F"><span class="toc-number">6.</span> <span class="toc-text">输入输出系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD"><span class="toc-number">6.1.</span> <span class="toc-text">1.基本功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="toc-number">6.2.</span> <span class="toc-text">2.层次结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-I-O%E7%A1%AC%E4%BB%B6"><span class="toc-number">6.3.</span> <span class="toc-text">3.I&#x2F;O硬件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%B8%AD%E6%96%AD%E5%8F%8A%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F"><span class="toc-number">6.4.</span> <span class="toc-text">4.中断及中断处理程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F"><span class="toc-number">6.5.</span> <span class="toc-text">5.设备驱动程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-I-O%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F"><span class="toc-number">6.6.</span> <span class="toc-text">6.I&#x2F;O控制方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E4%B8%8E%E8%AE%BE%E5%A4%87%E6%97%A0%E5%85%B3%E7%9A%84I-O%E8%BD%AF%E4%BB%B6"><span class="toc-number">6.7.</span> <span class="toc-text">7.与设备无关的I&#x2F;O软件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E7%94%A8%E6%88%B7%E5%B1%82%E7%9A%84I-O%E8%BD%AF%E4%BB%B6"><span class="toc-number">6.8.</span> <span class="toc-text">8.用户层的I&#x2F;O软件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6"><span class="toc-number">6.9.</span> <span class="toc-text">9.磁盘调度</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86"><span class="toc-number">7.</span> <span class="toc-text">文件管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%96%87%E4%BB%B6%E5%92%8C%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">7.1.</span> <span class="toc-text">1.文件和文件系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%96%87%E4%BB%B6%E7%9A%84%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84"><span class="toc-number">7.2.</span> <span class="toc-text">2.文件的逻辑结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95"><span class="toc-number">7.3.</span> <span class="toc-text">3.文件目录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB"><span class="toc-number">7.4.</span> <span class="toc-text">4.文件共享</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%96%87%E4%BB%B6%E4%BF%9D%E6%8A%A4"><span class="toc-number">7.5.</span> <span class="toc-text">5.文件保护</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2021/10/08/bash%E7%BC%96%E7%A8%8B/" title="bash编程">bash编程</a><time datetime="2021-10-08T00:23:52.000Z" title="Created 2021-10-08 08:23:52">2021-10-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2021/09/23/Linux%E5%A4%87%E5%BF%98%E5%BD%95/" title="Linux备忘录">Linux备忘录</a><time datetime="2021-09-23T02:03:51.000Z" title="Created 2021-09-23 10:03:51">2021-09-23</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2021/09/12/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/" title="加密算法">加密算法</a><time datetime="2021-09-12T13:04:03.000Z" title="Created 2021-09-12 21:04:03">2021-09-12</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2021/08/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/" title="操作系统概述">操作系统概述</a><time datetime="2021-08-29T07:16:36.000Z" title="Created 2021-08-29 15:16:36">2021-08-29</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2021/08/24/%E7%AE%80%E6%98%93%E6%B1%87%E7%BC%96%E5%85%A5%E9%97%A8/" title="简易汇编入门">简易汇编入门</a><time datetime="2021-08-24T09:25:41.000Z" title="Created 2021-08-24 17:25:41">2021-08-24</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Lightship</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html>